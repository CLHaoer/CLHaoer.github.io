<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git常用命令</title>
    <url>/2023/01/08/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Git-常用或常见的命令"><a href="#Git-常用或常见的命令" class="headerlink" title="Git 常用或常见的命令"></a>Git 常用或常见的命令</h1><h3 id="1-git"><a href="#1-git" class="headerlink" title="1. git"></a>1. git</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">VCS</span>  version  control system 版本控制系统</span><br><span class="line">git 开源的分布式版本控制系统</span><br><span class="line"><span class="comment">// 作用： 版本控制，存档</span></span><br></pre></td></tr></table></figure>

<h3 id="2-配置用户名和邮箱"><a href="#2-配置用户名和邮箱" class="headerlink" title="2. 配置用户名和邮箱"></a>2. 配置用户名和邮箱</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git config --<span class="variable language_">global</span> user.<span class="property">name</span> <span class="string">&quot;用户名&quot;</span></span><br><span class="line">git config --<span class="variable language_">global</span> user.<span class="property">email</span> <span class="string">&quot;邮箱&quot;</span></span><br><span class="line">查看配置</span><br><span class="line">git config --list </span><br><span class="line">查看全局配置</span><br><span class="line">git config --list --<span class="variable language_">global</span></span><br></pre></td></tr></table></figure>

<h3 id="3-初始化仓库"><a href="#3-初始化仓库" class="headerlink" title="3. 初始化仓库"></a>3. 初始化仓库</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 新建一个空文件夹，  右键 git bash here </span><br><span class="line"><span class="number">2.</span> ===&gt;  git init </span><br></pre></td></tr></table></figure>

<h3 id="4-查看文件的状态"><a href="#4-查看文件的状态" class="headerlink" title="4. 查看文件的状态"></a>4. 查看文件的状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status  </span><br><span class="line"><span class="comment"># 简写 </span></span><br><span class="line">git status --short </span><br><span class="line">git status -s</span><br><span class="line">红色： 工作区     绿色： 暂存区</span><br><span class="line">?? 文件未跟踪</span><br><span class="line">A  文件刚纳入跟踪</span><br><span class="line">M  表示文件已经修改了</span><br></pre></td></tr></table></figure>

<h3 id="5-git-add"><a href="#5-git-add" class="headerlink" title="5. git add"></a>5. git add</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 将未纳入跟踪（管理）的文件，纳入管理</span></span><br><span class="line">git add 文件名 </span><br><span class="line">git add .</span><br><span class="line"><span class="comment">// 2. 将修改后的文件，（工作区中），添加到暂存区 </span></span><br><span class="line">git add .</span><br><span class="line"><span class="comment">// ==&gt; git add . </span></span><br></pre></td></tr></table></figure>

<h3 id="6-提交更新（存档，记录一个版本）"><a href="#6-提交更新（存档，记录一个版本）" class="headerlink" title="6. 提交更新（存档，记录一个版本）"></a>6. 提交更新（存档，记录一个版本）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">只要commit之后，这次版本就永久的记录下来了 </span><br><span class="line">git commit -m <span class="string">&quot;本次提交的信息&quot;</span></span><br><span class="line"><span class="comment">// 每次提交的时候 </span></span><br><span class="line">工作区  ---&gt;  暂存区  ---&gt; git仓库</span><br><span class="line">git add . </span><br><span class="line">git commit -m <span class="string">&quot;update&quot;</span></span><br><span class="line">===&gt; 跳过暂存区， 前提是文件已经被git纳入跟踪管理</span><br><span class="line">git commit -am <span class="string">&quot;跳过暂存区&quot;</span> </span><br><span class="line"><span class="comment">// 修改最近一次提交说明 amend修正</span></span><br><span class="line">git commit --amend -m <span class="string">&quot;修改最近一次提交信息&quot;</span></span><br><span class="line"><span class="comment">// 1. 先修改文件 </span></span><br><span class="line"><span class="comment">// 2. git add .  / git commit -m &quot;提交信息&quot;</span></span><br><span class="line"><span class="comment">// 3. git commit --amend -m &quot;修改提交信息&quot;</span></span><br><span class="line"><span class="comment">// 4. git log --oneline 查看</span></span><br></pre></td></tr></table></figure>

<h3 id="7-查看历史提交记录"><a href="#7-查看历史提交记录" class="headerlink" title="7. 查看历史提交记录"></a>7. 查看历史提交记录</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git log  详细信息</span><br><span class="line">git log -<span class="number">2</span> 查看两条</span><br><span class="line">git log --oneline  简洁的查看  ==&gt; 推荐</span><br><span class="line"><span class="comment">// 如果回退到某个版本之后，还想切换另一个版本 查看所有的提交记录</span></span><br><span class="line">git reflog </span><br></pre></td></tr></table></figure>

<h3 id="8-回退指定版本"><a href="#8-回退指定版本" class="headerlink" title="8. 回退指定版本"></a>8. 回退指定版本</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 回退</span><br><span class="line">git reset --hard 版本id   </span><br><span class="line"><span class="number">2.</span> 将暂存区的文件 移动到 工作区</span><br><span class="line">git reset <span class="variable constant_">HEAD</span> .  （所有的文件）</span><br></pre></td></tr></table></figure>

<h3 id="9-撤销对文件的修改"><a href="#9-撤销对文件的修改" class="headerlink" title="9. 撤销对文件的修改"></a>9. 撤销对文件的修改</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用的很少 </span></span><br><span class="line"><span class="comment">// 就是将工作区的文件，用仓库中当前版本替换掉。</span></span><br><span class="line">git checkout 文件名 </span><br><span class="line"><span class="comment">// 类似ctrl + Z</span></span><br></pre></td></tr></table></figure>

<h3 id="10-将纳入git管理的文件移除"><a href="#10-将纳入git管理的文件移除" class="headerlink" title="10 将纳入git管理的文件移除"></a>10 将纳入git管理的文件移除</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将纳入git管理的文件变为未跟踪的状态</span></span><br><span class="line">git rm --cached 文件名  <span class="comment">// 一个文件</span></span><br><span class="line">git rm --cached -r .   <span class="comment">// 所有文件 </span></span><br><span class="line">git rm -r --cached .  <span class="comment">// -r的位置可以交换</span></span><br></pre></td></tr></table></figure>

<h3 id="11-忽略某些文件，不需要被git管理"><a href="#11-忽略某些文件，不需要被git管理" class="headerlink" title="11. 忽略某些文件，不需要被git管理"></a>11. 忽略某些文件，不需要被git管理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个新的文件 sercet.js</span></span><br><span class="line"><span class="number">1.</span> 创建一个.<span class="property">gitignore</span> 文件</span><br><span class="line"><span class="number">2.</span> 将不需要纳入git管理的这个文件，写到里面  # 表示注释</span><br><span class="line"><span class="number">3.</span> git add .</span><br><span class="line"><span class="number">4.</span> git commit -m <span class="string">&quot;添加gitignore文件&quot;</span></span><br><span class="line"><span class="number">5.</span> 再修改这个文件， git status查看一下状态</span><br><span class="line">----</span><br><span class="line">.<span class="property">gitignore</span> 只忽略没有跟踪的文件 如果文件已经纳入git管理了，则修改.<span class="property">gitignore</span>无效 </span><br><span class="line"><span class="comment">// 解决方案</span></span><br><span class="line"><span class="number">1.</span> 在gitignore文件中写需要忽略的文件信息</span><br><span class="line"><span class="number">2.</span> 让所有纳入git管理的文件，都变为未跟踪</span><br><span class="line">git rm -r --cached .</span><br><span class="line"><span class="number">3.</span> git add .  重新添加到暂存区 ，再提交</span><br><span class="line"><span class="number">4.</span> 提交当前的更新，备注说明 （添加了gitignore）</span><br></pre></td></tr></table></figure>

<h3 id="12-中文乱码解决"><a href="#12-中文乱码解决" class="headerlink" title="12 中文乱码解决"></a>12 中文乱码解决</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解决git status中文显示问题</span></span><br><span class="line">git config --<span class="variable language_">global</span> core.<span class="property">quotepath</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="13-VSCode-配置git-bash"><a href="#13-VSCode-配置git-bash" class="headerlink" title="13 VSCode 配置git bash"></a>13 VSCode 配置git bash</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Ctrl + j  </span></span><br><span class="line"><span class="comment">// cmd + j</span></span><br><span class="line"><span class="title class_">Ctrl</span> + shift + p  ==&gt; 输入 <span class="title class_">JSON</span> </span><br><span class="line"><span class="comment">// where git </span></span><br><span class="line"><span class="comment">// path 修改为Git bash的路径</span></span><br><span class="line"><span class="string">&quot;terminal.integrated.profiles.windows&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;PowerShell -NoProfile&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;source&quot;</span>: <span class="string">&quot;PowerShell&quot;</span>,</span><br><span class="line">      <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;-NoProfile&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;Git-Bash&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;path&quot;</span>: <span class="string">&quot;D:\\Program Files\\Git\\bin\\bash.exe&quot;</span>,  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="string">&quot;terminal.integrated.defaultProfile.windows&quot;</span>: <span class="string">&quot;Git-Bash&quot;</span>,</span><br></pre></td></tr></table></figure>

<h3 id="14-一些常见的命令"><a href="#14-一些常见的命令" class="headerlink" title="14  一些常见的命令"></a>14  一些常见的命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 文件夹名字  进入某个文件夹</span><br><span class="line"><span class="built_in">cd</span> ..  返回上一层       ./ 一个点表示当前目录 .. 上级目录</span><br><span class="line">clear 清屏 （git-bash）</span><br><span class="line">cls  清屏  window黑色终端 cmd中 </span><br><span class="line"><span class="comment"># 查看文件内容</span></span><br><span class="line"><span class="built_in">cat</span> 文件名</span><br><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> 文件夹名  </span><br><span class="line"><span class="comment"># 创建文件</span></span><br><span class="line"><span class="built_in">touch</span> 文件名 </span><br><span class="line"><span class="comment"># 查看文件列表</span></span><br><span class="line"><span class="built_in">ls</span> </span><br><span class="line"><span class="comment"># 显示当前目录</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line">使用 Vim编辑器 修改内容</span><br><span class="line">vi 文件名  </span><br><span class="line"><span class="comment"># 进入vim编辑模式 </span></span><br><span class="line">进入这个模式之后， 按键盘 i   ==》 插入模式 可以输入内容</span><br><span class="line"><span class="comment"># 退出？</span></span><br><span class="line">1. 按ESC </span><br><span class="line">2. <span class="built_in">shift</span>+:  =&gt; 冒号（英文）</span><br><span class="line">:q   不保存退出</span><br><span class="line">:q!  不保存强制退出</span><br><span class="line">:w   保存</span><br><span class="line">:wq   保存并退出</span><br><span class="line">:wq!  强制保存退出</span><br></pre></td></tr></table></figure>

<h3 id="15-推送到远端"><a href="#15-推送到远端" class="headerlink" title="15 推送到远端"></a>15 推送到远端</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="variable constant_">HTTPS</span>   ==&gt; 直接用链接推送  推送完之后要输入账号密码   </span><br><span class="line"><span class="number">2.</span> <span class="variable constant_">SSH</span>    ==&gt; 推荐的方式，密钥对 。</span><br><span class="line">私钥  本地电脑上</span><br><span class="line">公钥  需要配置到github / gitee / gitlab 平台上</span><br></pre></td></tr></table></figure>

<h3 id="16-打开gitee网站上，查看SSH，右下角怎么生成秘钥"><a href="#16-打开gitee网站上，查看SSH，右下角怎么生成秘钥" class="headerlink" title="16 打开gitee网站上，查看SSH，右下角怎么生成秘钥"></a>16 打开gitee网站上，查看SSH，右下角怎么生成秘钥</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 生成密钥对 </span><br><span class="line"><span class="attr">https</span>:<span class="comment">//gitee.com/help/articles/4181#article-header0</span></span><br><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;xxxxx@xxxxx.com&quot;</span>   改一下邮箱</span><br><span class="line"><span class="number">2.</span> 将公钥配置到gitee/github平台上</span><br><span class="line">cat ~<span class="regexp">/.ssh/i</span>d_ed25519.<span class="property">pub</span></span><br><span class="line"><span class="number">3.</span> 验证是否配置秘钥成功 </span><br><span class="line">ssh -T git@gitee.<span class="property">com</span>‘</span><br><span class="line"><span class="number">4.</span> 先移除原来的origin名称 </span><br><span class="line">git remote rm origin </span><br><span class="line">git remote -v 查看 </span><br><span class="line"><span class="number">5.</span> 重新关联仓库</span><br><span class="line">git remote add origin git地址 （ssh）</span><br><span class="line"><span class="number">6.</span> 第一次推送</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h3 id="17-之后的每次推送"><a href="#17-之后的每次推送" class="headerlink" title="17 之后的每次推送"></a>17 之后的每次推送</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">推送 把本地（电脑上的修改的版本更新  同步到远端）</span><br><span class="line"><span class="comment">// 修改代码，修改之后</span></span><br><span class="line"><span class="number">1.</span> git add . </span><br><span class="line"><span class="number">2.</span> git commit -m <span class="string">&quot;msg&quot;</span></span><br><span class="line"><span class="number">3.</span> git push </span><br></pre></td></tr></table></figure>



<h3 id="18-分支-branch"><a href="#18-分支-branch" class="headerlink" title="18 分支 branch"></a>18 分支 branch</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 查看分支</span></span><br><span class="line">git branch  </span><br><span class="line"><span class="comment"># 2. 新建一个分支 </span></span><br><span class="line">git branch 新分支名字  （基于当前的分支，创建一个新分支）</span><br><span class="line"><span class="comment"># 3. 切换分支</span></span><br><span class="line">git checkout 分支名字</span><br><span class="line"><span class="comment"># 4. 简写 创建一个分支，并切换分支</span></span><br><span class="line">git checkout -b 新分支的名字 </span><br><span class="line"><span class="comment"># 5. 合并 </span></span><br><span class="line"><span class="comment"># 1. 在其他分支上修改的内容，一定要记得提交更新（记录）</span></span><br><span class="line"><span class="comment"># 2. 合并之前 切换到master分支上合并</span></span><br><span class="line">git merge 分支名字</span><br><span class="line"><span class="comment"># 6. 删除分支</span></span><br><span class="line">git branch -d 分支的名字  不能自己删除自己</span><br><span class="line"><span class="comment"># 下载项目（拉项目）</span></span><br><span class="line">git <span class="built_in">clone</span>  项目地址 （SSH / HTTPS）</span><br></pre></td></tr></table></figure>

<h3 id="19-合并冲突"><a href="#19-合并冲突" class="headerlink" title="19 合并冲突"></a>19 合并冲突</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 产生的场景 不同的分支，对同一份文件，（同一个位置）做了不同的修改，再合并这两个分支的时候，就会产生冲突。conflict</span><br><span class="line"><span class="number">2.</span> 在新分支中 找一个文件 记下位置，修改代码，</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;提交&quot;</span></span><br><span class="line">（目前处于刚创建好的分支）</span><br><span class="line"><span class="number">3.</span> 选择一个要保留的分支代码  </span><br><span class="line">保存之后，</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;解决了冲突&quot;</span></span><br><span class="line"><span class="comment">// 1. 采用当前的更改  2. 采用传入的修改  3. 保留两个分支的修改  4. 比较变更</span></span><br><span class="line"><span class="comment">// 还可以手动操作  ===&gt; 不要忘记了删除哪些  ==== &gt;&gt;&gt;&gt; &lt;&lt;&lt;&lt;&lt;&lt;</span></span><br></pre></td></tr></table></figure>

<h2 id="20-远端分支"><a href="#20-远端分支" class="headerlink" title="20 远端分支"></a>20 远端分支</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># -u 表示把本地分支和远程分支进行关联，只在第一次推送的时候需要带 -u 参数</span><br><span class="line">git push -u 远程仓库的别名 本地分支名称:远程分支名称</span><br><span class="line"># 实际案例   :重命名    原来名字:新名字</span><br><span class="line">git push -u origin <span class="attr">payment</span>:pay</span><br><span class="line"># 如果希望远程分支的名称和本地分支名称保持一致，可以对命令进行简化</span><br><span class="line">git push -u origin payment</span><br></pre></td></tr></table></figure>

<h3 id="21-推送本地的分支到远端"><a href="#21-推送本地的分支到远端" class="headerlink" title="21 推送本地的分支到远端"></a>21 推送本地的分支到远端</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 创建一个本地的分支并切换  local</span><br><span class="line"><span class="number">2.</span> 修改部分代码</span><br><span class="line"><span class="number">3.</span> git add . /  git commit -m <span class="string">&quot;msg&quot;</span></span><br><span class="line"><span class="number">4.</span> 本地这个local推送到远端 </span><br><span class="line">git push -u origin 本地分支的名字:远端分支名字</span><br><span class="line">git push -u origin local </span><br></pre></td></tr></table></figure>

<h3 id="22-将远端分支下载到本地"><a href="#22-将远端分支下载到本地" class="headerlink" title="22 将远端分支下载到本地"></a>22 将远端分支下载到本地</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 先删除本地的分支  </span><br><span class="line">git branch -d 本地分支名字</span><br><span class="line"><span class="number">2.</span> git checkout 远端分支名字 </span><br><span class="line">==&gt; 下载远端分支，并切换到那个分支上去</span><br></pre></td></tr></table></figure>

<h3 id="23-删除远端分支"><a href="#23-删除远端分支" class="headerlink" title="23 删除远端分支"></a>23 删除远端分支</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 删除远程仓库中，指定名称的远程分支</span><br><span class="line">git push 远程仓库名称 --<span class="keyword">delete</span> 远程分支名称</span><br><span class="line"># 示例</span><br><span class="line">git push origin --<span class="keyword">delete</span> pay</span><br></pre></td></tr></table></figure>

<h3 id="24-实际开发的情况"><a href="#24-实际开发的情况" class="headerlink" title="24 实际开发的情况"></a>24 实际开发的情况</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dev  开发环境</span><br><span class="line">test 测试环境</span><br><span class="line">master 主分支 （线上环境）</span><br><span class="line">master-login --&gt; 把这个分支的代码 合并到test分支上 ， 测试人员测试我们的代码功能等是否有问题</span><br><span class="line">master-login  最后等待上线 。。  某个周五的晚上 </span><br><span class="line">git push   ==》 把这个分支推送到远端仓库</span><br><span class="line">gitlab 你的组长 帮你合并分支 </span><br></pre></td></tr></table></figure>



<h2 id="25-去公司的第一天"><a href="#25-去公司的第一天" class="headerlink" title="25 去公司的第一天"></a>25 去公司的第一天</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> leader 给你分配邮箱，账号</span><br><span class="line"><span class="number">2.</span> leader 给你一个 gitlab的地址， 同时，配套给你邮箱和密码    zxd@公司名字.<span class="property">com</span>  密码 </span><br><span class="line"><span class="number">3.</span> 用公司给的邮箱密码，登录gitlab</span><br><span class="line"><span class="number">4.</span> 配置<span class="variable constant_">SSH</span>， 方式和我们今天讲的一样   </span><br><span class="line"><span class="number">5.</span> 需要你的leader给你一个访问项目的权限 ，如果没有，是拉不了代码的   git <span class="title function_">pull</span>(下载)</span><br><span class="line"><span class="number">6.</span> git clone 项目地址  下载项目。</span><br><span class="line"><span class="number">7.</span> 熟悉代码 </span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> git status</span><br><span class="line"><span class="number">2.</span> git add .</span><br><span class="line"><span class="number">3.</span> git commit -m <span class="string">&quot;update&quot;</span></span><br><span class="line"><span class="number">4.</span> git push </span><br><span class="line"><span class="number">5.</span> 新建分支，基于master新建分支并切换到那个分支</span><br><span class="line">git checkout -b 分支名 </span><br><span class="line"><span class="number">6.</span> 合并分支  git merge </span><br><span class="line">推送到远端仓库的时候，远端仓库的地址 </span><br><span class="line">git remote add origin 地址名 </span><br><span class="line">移除它</span><br><span class="line">git remote rm origin</span><br><span class="line">git remote -v 查看关联上了哪个分支 </span><br><span class="line">代码回退 </span><br><span class="line">git reset --hard id  </span><br><span class="line">git reflog </span><br><span class="line">git log --oneline</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>推荐</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/01/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>宁波北斗易飞面试</title>
    <url>/2023/01/10/%E5%AE%81%E6%B3%A2%E5%8C%97%E6%96%97%E6%98%93%E9%A3%9E/</url>
    <content><![CDATA[<h2 id="1-项目部署流程"><a href="#1-项目部署流程" class="headerlink" title="1.项目部署流程"></a>1.项目部署流程</h2><p>1.控制台输入npm run build ，生成dist文件夹</p>
<p>2.下载传输文件工具, 把打包好的文件（dist内的文件）上传到你的服务器 , 如果只是简单的服务器例如阿里云OSS服务器可直接账号密码登录后，把dist里对应的html，css，js文件上传至对应的域名服务器下即可；还有一些是后端要用到软件例如：Xftp、xshell等 （需要去学习这个软件的使用方法）</p>
<p>3.修改nginx配置（有的公司是后端配置也有前端配置）可以直接改nginx的配置文件（需要学习一点nginx)</p>
<h2 id="2-项目上线流程"><a href="#2-项目上线流程" class="headerlink" title="2.项目上线流程"></a>2.项目上线流程</h2><p>1.后台上线如1问一样，打包部署到服务器上即可</p>
<p>2.小程序上线在微信开发者平台进行发版上传，等待微信官方审核</p>
<p>3.APP上线安卓和IOS都是打包好的安装包上传至各个厂商的应用市场，安卓还可以发布到如豌豆荚、腾讯（360）应用宝等平台。</p>
<h2 id="3-前端概念"><a href="#3-前端概念" class="headerlink" title="3.前端概念"></a>3.前端概念</h2><p>前端应用就是指运行在各种终端设备的程序及资源</p>
<h2 id="4-字符串随机打乱思路"><a href="#4-字符串随机打乱思路" class="headerlink" title="4.字符串随机打乱思路"></a>4.字符串随机打乱思路</h2><p>字符串随机打乱思路可以先把字符串转成数组，然后不断的从数组中随机抽选元素拼接到字符串中，但切记随机抽选到的元素需要被标记上，下次不能再抽取到它<strong>（答案不唯一主要是突出不重复的取数组元素思路，例：需要声明一个数组，数组里面放每次随机的数组下标，每次随机的下标需要跟这个数组进行一个去重，如有重复则重新抽取，没有重复则拿出来）</strong></p>
<h2 id="5-app迭代更新方式"><a href="#5-app迭代更新方式" class="headerlink" title="5.app迭代更新方式"></a>5.app迭代更新方式</h2><p>app更新方式通常分两种，一种为整包更新，这种是如有新版本，服务器主动推送给客户端提示下载，点击跳转应用市场或网站链接下载；<br>另一种为热更新，用户进入客户端后，通过对比客户端的版本号来进行提示用户是否更新，用户点击后即可进行下载新版本资源包</p>
<h2 id="6-cdn如何进入到页面"><a href="#6-cdn如何进入到页面" class="headerlink" title="6.cdn如何进入到页面"></a>6.cdn如何进入到页面</h2><pre><code>   CDN，全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。
</code></pre>
<p>此问题在于考查CDN原理，以及如何在项目中使用CDN  .举例如下：</p>
<p>vue.config.js文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">configureWebpack: &#123;</span><br><span class="line">        externals: &#123;</span><br><span class="line">            // CDN 的 Element 依赖全局变量 Vue， 所以 Vue 也需要使用 CDN 引入</span><br><span class="line">            &#x27;vue&#x27;: &#x27;Vue&#x27;,</span><br><span class="line">            // 属性名称 element-ui, 表示遇到 import xxx from &#x27;element-ui&#x27; 这类引入 &#x27;element-ui&#x27;的，</span><br><span class="line">            // 不去 node_modules 中找，而是去找 全局变量 ELEMENT</span><br><span class="line">            &#x27;element-ui&#x27;: &#x27;ELEMENT&#x27;,</span><br><span class="line">            &#x27;axios&#x27;: &#x27;axios&#x27;,</span><br><span class="line">            &#x27;vuex&#x27;: &#x27;Vuex&#x27;,</span><br><span class="line">            &#x27;vue-router&#x27;: &#x27;VueRouter&#x27;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>



<h2 id="7-员工如何访问到页面的"><a href="#7-员工如何访问到页面的" class="headerlink" title="7.员工如何访问到页面的"></a>7.员工如何访问到页面的</h2><p>这道题题意不明确：只能理解要么考察权限问题，要么考察地址栏输入URL发生了什么</p>
<p>1.权限问题，动态路由权限，侧边导航栏权限，按钮权限等</p>
<p>2.地址栏输入URL发生了什么：</p>
<p>​    （1）.先本地缓存查找</p>
<p>​    （2）.DNS域名解析</p>
<p>​    （3）.建立TCP链接</p>
<p>​    （4）.发起HTTP请求</p>
<p>​    （5）.接收响应结果</p>
<p>​    （6）.浏览器解析HTML并渲染出来</p>
<p>其中每个步骤里面分了很多小步骤，想要详情了解<a href="https://cloud.tencent.com/developer/article/1493941">https://cloud.tencent.com/developer/article/1493941</a></p>
]]></content>
      <categories>
        <category>八股文</category>
      </categories>
  </entry>
  <entry>
    <title>成都乐度软件面试</title>
    <url>/2023/01/10/%E6%88%90%E9%83%BD%E4%B9%90%E5%BA%A6%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="1-HTTP状态码及其含义"><a href="#1-HTTP状态码及其含义" class="headerlink" title="1.HTTP状态码及其含义"></a>1.HTTP状态码及其含义</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1XX</span><br></pre></td></tr></table></figure>

<ul>
<li><code>100 Continue</code>   继续，一般在发送<code>post</code>请求时，已发送了<code>http header</code>之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2XX</span><br></pre></td></tr></table></figure>

<ul>
<li>200 OK`         正常返回信息</li>
<li><code>201 Created</code>   请求成功并且服务器创建了新的资源</li>
<li><code>202 Accepted</code>   服务器已接受请求，但尚未处理</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3XX</span><br></pre></td></tr></table></figure>

<ul>
<li><code>301 Moved Permanently</code>  请求的网页已永久移动到新位置。</li>
<li><code>302 Found</code>     临时性重定向。</li>
<li><code>303 See Other</code>  临时性重定向，且总是使用 <code>GET</code> 请求新的 <code>URI</code>。</li>
<li><code>304 Not Modified</code> 自从上次请求后，请求的网页未修改过。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4XX</span><br></pre></td></tr></table></figure>

<ul>
<li><code>400 Bad Request</code> 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li>
<li><code>401 Unauthorized</code> 请求未授权。</li>
<li><code>403 Forbidden</code>  禁止访问。</li>
<li><code>404 Not Found</code>   找不到如何与 <code>URI</code> 相匹配的资源。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5XX:</span><br></pre></td></tr></table></figure>

<ul>
<li><code>500 Internal Server Error</code>  最常见的服务器端错误。</li>
<li><code>503 Service Unavailable</code> 服务器端暂时无法处理请求（可能是过载或维护）。</li>
</ul>
<h2 id="2-null，undefined-的区别"><a href="#2-null，undefined-的区别" class="headerlink" title="2.null，undefined 的区别"></a>2.null，undefined 的区别</h2><p><code>undefined</code>   表示不存在这个值。</p>
<p><code>undefined</code> :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 <code>undefined</code></p>
<p>例如变量被声明了，但没有赋值时，就等于<code>undefined</code></p>
<p><code>null</code> 表示一个对象被定义了，值为“空值”</p>
<p><code>null</code> : 是一个对象(空对象, 没有任何属性和方法)</p>
<p>例如作为函数的参数，表示该函数的参数不是对象；</p>
<p>在验证<code>null</code>时，一定要使用　<code>===</code> ，因为 <code>==</code>无法分别<code>null</code> 和　<code>undefined</code></p>
<h2 id="3-vuex有哪些属性"><a href="#3-vuex有哪些属性" class="headerlink" title="3.vuex有哪些属性"></a>3.<strong>vuex有哪些属性</strong></h2><p>state：用于数据的存储，是store中的唯一数据源</p>
<p>getters：如vue中的计算属性一样，基于state数据的二次包装，常用于数据的筛选和多个数据的相关性计算</p>
<p>mutation：类似函数，改变state数据的唯一途径，且不能用于处理异步事件</p>
<p>action：类似于mutation，用于提交mutation来改变状态，而不直接变更状态，可以包含任意异步操作</p>
<p>modules：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护</p>
<h2 id="4-vue中的路由模式"><a href="#4-vue中的路由模式" class="headerlink" title="4.vue中的路由模式"></a>4.<strong>vue中的路由模式</strong></h2><h3 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h3><p>HTML5中的两个API：pushState和replaceState，改变url之后页面不会重新刷新，也不会带有#号，页面地址美观，url的改变会触发popState事件，监听该事件也可以实现根据不同的url渲染对应的页面内容</p>
<p>但是因为没有#会导致用户在刷新页面的时候，还会发送请求到服务端，为避免这种情况，需要每次url改变的时候，都将所有的路由重新定位到跟路由下</p>
<h3 id="hash模式"><a href="#hash模式" class="headerlink" title="hash模式"></a>hash模式</h3><p>url hash: http ://foo.com/#help</p>
<p>后面hash值的改变，并不会重新加载页面，同时hash值的变化会触发hashchange事件，该事件可以监听，可根据不同的哈希值渲染不同的页面内容</p>
<h2 id="5-GET-POST的本质区别"><a href="#5-GET-POST的本质区别" class="headerlink" title="5.GET/POST的本质区别"></a>5.<strong>GET/POST的本质区别</strong></h2><p>GET/POST的最大区别是GET请求有幂等性，但是POST请求没有。什么是幂等性呢？我们知道使用GET方法请求同样的接口，返回来的数据是不会改变的，但是对于POST请求，实现一些增删改查的操作的时候可能会发生重复提交的问题。</p>
<p>也就是说我们如果使用GET请求做增删改查的时候，遇到网络不好可能会多次操作，造成数据库的混乱，这是一个很严重的问题，但是使用POST就不会有这种情况。</p>
<h2 id="6-CDN的优化原理"><a href="#6-CDN的优化原理" class="headerlink" title="6.CDN的优化原理"></a>6.<strong>CDN的优化原理</strong></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CDN的全称是(Content Delivery Network)，即内容分发网络。其目的是通过在现有的Internet中增加一层新的CACHE(缓存)层，将网站的内容发布到最接近用户的网络”边缘“的节点，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。</span><br><span class="line">CDN的工作原理就是将您源站的资源缓存到位于全球各地的CDN节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都回您的源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>八股文</category>
      </categories>
  </entry>
  <entry>
    <title>成都法本面试</title>
    <url>/2023/01/10/%E6%88%90%E9%83%BD%E6%B3%95%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="1-vue-的生命周期有哪些？"><a href="#1-vue-的生命周期有哪些？" class="headerlink" title="1.vue 的生命周期有哪些？"></a>1.vue 的生命周期有哪些？</h2><p>一、创建前 / 后 在<code>beforeCreate</code>生命周期函数执行的时候，data 和 method 还没有初始化 在<code>created </code>生命周期函数执行的时候，data 和 method 已经初始化完成</p>
<p>二、渲染前/后 在<code>beforeMount</code> 生命周期函数执行的时候，已经编译好了模版字符串、但还没有真正渲染到页面中去 在<code>mounted </code>生命周期函数执行的时候，已经渲染完，可以看到页面</p>
<p>三、数据更新前/后 在<code>beforeUpdate</code>生命周期函数执行的时候，已经可以拿到最新的数据，但还没渲染到视图中去。在<code>updated</code>生命周期函数执行的时候，已经把更新后的数据渲染到视图中去了。</p>
<p>四、销毁前/后 在<code>beforeDestroy </code>生命周期函数执行的时候，实例进入准备销毁的阶段、此时 data 、methods 、指令 等还是可用状态 在<code>destroyed</code>生命周期函数执行的时候，实例已经完成销毁、此时 data 、methods 、指令等都不可用</p>
<h2 id="2-常用的数组方法有哪些？"><a href="#2-常用的数组方法有哪些？" class="headerlink" title="2.常用的数组方法有哪些？"></a>2.常用的数组方法有哪些？</h2><p><strong>concat()</strong> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p>
<p><strong>find()</strong> 方法<strong>返回数组中满足提供的测试函数的第一个元素的值</strong>。否则返回 undefined 。</p>
<p><strong>findIndex()</strong> 方法返回数组中满足提供的测试函数的<strong>第一个元素的索引</strong>。否则返回-1。</p>
<p><strong>includes()</strong> 方法用来<strong>判断一个数组是否包含一个指定的值</strong>，根据情况，如果包含则返回 true， 否则返回 false。</p>
<p><strong>indexOf()</strong> 方法返回在数组中可以<strong>找到一个给定元素的第一个索引</strong>，如果<strong>不存在，则返回-1</strong>。 （通常用它判断数组中有没有这个元素）</p>
<p><strong>join()</strong> 方法将一个数组（或一个类数组对象）的所有元素<strong>连接成一个字符串并返回这个字符串</strong>。 如果数组只有一个项目，那么将返回该项目而不使用分隔符。</p>
<p>…</p>
<h2 id="3-v-for-循环为什么一定要绑定-key"><a href="#3-v-for-循环为什么一定要绑定-key" class="headerlink" title="3.v-for 循环为什么一定要绑定 key ?"></a>3.v-for 循环为什么一定要绑定 key ?</h2><p><strong>页面上的标签都对应具体的虚拟 dom 对象(虚拟 dom 就是 js 对象),</strong> 循环中 ,如果没有唯一 key , 页面上删除 一条标签, 由于并不知道删除的是那一条! 所以要把全部虚拟 dom 重新渲染, 如果知道 key 为 x 标签被删除 掉, 只需要把渲染的 dom 为 x 的标签去掉即可</p>
<h2 id="4-平时都是用什么实现跨域的"><a href="#4-平时都是用什么实现跨域的" class="headerlink" title="4.平时都是用什么实现跨域的"></a>4.平时都是用什么实现跨域的</h2><p>一：cors跨域，服务端设置一个acess-control-allow-origin的属性来控制可跨域访问的请求地址</p>
<p>二：proxy代理，vue开发阶段可使用脚手架提供的proxy代理，不过通常只能子啊开发环境下使用</p>
<p>三：nginx代理跨域</p>
<p>四：jsonp的跨域，局限性只能跨域访问get请求</p>
<h2 id="5-this-的指向有哪些"><a href="#5-this-的指向有哪些" class="headerlink" title="5.this 的指向有哪些"></a>5.this 的指向有哪些</h2><p>1、普通函数中的 this 指向 window</p>
<p>2、定时器中的 this 指向 window</p>
<p>3、箭头函数没有 this,它的 this 指向取决于外部环境、</p>
<p>4、事件中的 this 指向事件的调用者 黑马程序员</p>
<p>5、 构造函数中 this 和原型对象中的 this,都是指向构造函数 new 出来实例对象</p>
<p>6、类 class 中的 this 指向由 constructor 构造器 new 出来的实例对象</p>
<p>7、自调用函数中的 this 指向 window</p>
<h2 id="6-vue-中-computed-和-watch-的区别是什么"><a href="#6-vue-中-computed-和-watch-的区别是什么" class="headerlink" title="6.vue 中 computed 和 watch 的区别是什么"></a>6.vue 中 computed 和 watch 的区别是什么</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">computed计算属性就是为了简化 template 里面模版字符串的计算复杂度、防止模版太过冗余。</span><br><span class="line">它具有 缓存特性 computed 用来监控自己定义的变量，该变量不在 data 里面声明，直接在 computed 里面定义，然后就 可以在页面上进行双向数据绑定展示出结果或者用作其他处理；</span><br><span class="line">watch主要用于监控 vue 实例的变化，它监控的变量当然必须在 data 里面声明才可以，它可以监控一个 变量，也可以是一个对象，一般用于监控路由、input 输入框的值特殊处理等等，它比较适合的场景是 一个数据影响多个数据，它不具有缓存性</span><br><span class="line"></span><br><span class="line">watch：监测的是属性值， 只要属性值发生变化，其都会触发执行回调函数来执行一系列操作。</span><br><span class="line">computed：监测的是依赖值，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才 会重新计算。</span><br><span class="line"></span><br><span class="line">除此之外，有点很重要的区别是：计算属性不能执行异步任务，计算属性必须同步执行。也就是说计算 属性不能向服务器请求或者执行异步任务。如果遇到异步任务，就交给侦听属性。watch 也可以检测 computed 属性。</span><br></pre></td></tr></table></figure>



<h2 id="7-箭头函数有哪些特征，请简单描述一下它"><a href="#7-箭头函数有哪些特征，请简单描述一下它" class="headerlink" title="7.箭头函数有哪些特征，请简单描述一下它"></a>7.箭头函数有哪些特征，请简单描述一下它</h2><p><strong>箭头函数没有自己的 this</strong>，this 指向定义箭头函数时所处的<strong>外部执行环境的 this</strong></p>
<p>即使调用<strong>call/apply/bind</strong>也无法改变箭头函数的 this 箭头函数本身没有名字 <strong>箭头函数不能 new，会报错</strong></p>
<p>箭头函数没有 arguments，在箭头函数内访问这个变量访问的是外部执行环境的 arguments <strong>箭头函数没有 prototype</strong></p>
]]></content>
      <categories>
        <category>八股文</category>
      </categories>
  </entry>
  <entry>
    <title>前端部分方法的手写实现</title>
    <url>/2023/01/10/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="手写实现一个new"><a href="#手写实现一个new" class="headerlink" title="手写实现一个new"></a>手写实现一个new</h2><ol>
<li>创建一个空的简单JavaScript对象（即{}）；</li>
<li>为步骤1新创建的对象添加属性<code>__proto__</code>，将该属性链接至构造函数的原型对象 ；</li>
<li>将步骤1新创建的对象作为this的上下文 ；</li>
<li>如果该函数没有返回对象，则返回this。</li>
</ol>
<blockquote>
<p>new关键词执行后总会返回一个对象, 要么是实例对象, 要么是return语句指定的对象.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params">fn,...args</span>)&#123;</span><br><span class="line">    <span class="comment">// let obj = new Object()</span></span><br><span class="line">    <span class="comment">// obj.__proto__ = fn.prototype</span></span><br><span class="line">    <span class="comment">// 基于fn构造函数原型创建一个新对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(fn.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    <span class="comment">// 执行构造函数，并获取fn执行的结果</span></span><br><span class="line">    <span class="keyword">let</span> res = fn.<span class="title function_">call</span>(obj,...args) </span><br><span class="line">    <span class="comment">// 如果执行结果有返回值并且是一个对象，返回执行结果，否则，返回新创建的对象</span></span><br><span class="line">    <span class="keyword">let</span> isObject = <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> isFunction = <span class="keyword">typeof</span> res === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> isObject || isFunction  ? res : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好理解</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myNew</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(fn.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">  <span class="keyword">let</span> res = fn.<span class="title function_">call</span>(obj,...args)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (res &amp;&amp; (<span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> res === <span class="string">&#x27;function&#x27;</span>)) retrun res</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">create</span> (o) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个对象，以o为新创建对象的原型对象</span></span><br></pre></td></tr></table></figure>

<h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><ul>
<li>Instanceof: 用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</li>
<li>通俗一点就是： 判断new出的实例对象是否是当前构造函数生成的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">my_instanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="comment">// 这里先用typeof来判断基础数据类型，如果是，直接返回false</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> left !== <span class="string">&#x27;object&#x27;</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// getProtypeOf是Object对象自带的API</span></span><br><span class="line">  <span class="comment">// 返回指定对象的原型（内部[[Prototype]]属性的值）隐式原型</span></span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left);</span><br><span class="line">  <span class="keyword">let</span> prototype = right.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;                  <span class="comment">//循环往下寻找，直到找到相同的原型对象</span></span><br><span class="line">    <span class="keyword">if</span>(proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//找到相同原型对象，返回true</span></span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeof</span>(proto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好理解版本</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">my_instanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> left !== <span class="string">&#x27;object&#x27;</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">let</span> proto = left.<span class="property">__proto__</span></span><br><span class="line">    <span class="keyword">let</span> prototype = right.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// 右边的原型</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        proto = proto.<span class="property">__proto__</span> <span class="comment">// 向上查找，直到proto为null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="🔥手写Promise-all"><a href="#🔥手写Promise-all" class="headerlink" title="🔥手写Promise.all"></a>🔥手写Promise.all</h2><ol>
<li>参数可迭代</li>
<li>返回值是promise</li>
<li>如果全部成功，状态变为resolve</li>
<li>但凡有一个失败，状态变为reject</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">PromiseAll</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`<span class="subst">$&#123;arr&#125;</span> is not iterable`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> result = []  <span class="comment">// 存放结果</span></span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span> <span class="comment">// 进入fullfilled的promise个数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 这里默认把所有入参都包装成promise返回了</span></span><br><span class="line">            <span class="comment">// 因为如果是普通值,在Promise内部实现 2.3.4时, 有返回值的操作</span></span><br><span class="line">            <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(arr[i]).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// counter++;</span></span><br><span class="line">                result[i] = value;</span><br><span class="line">                <span class="keyword">if</span> ( ++count === arr.<span class="property">length</span>) <span class="title function_">resolve</span>(result) <span class="comment">//判断已经完成</span></span><br><span class="line">                <span class="comment">// 只要有一个被rejected时, 就reject</span></span><br><span class="line">            &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">reject</span>(e))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="手写call-apply-bind"><a href="#手写call-apply-bind" class="headerlink" title="手写call, apply, bind"></a>手写call, apply, bind</h2><ul>
<li><a href="https://juejin.cn/post/6844904042452221960#heading-9">https://juejin.cn/post/6844904042452221960#heading-9</a> 可参考</li>
<li><a href="https://juejin.cn/post/6844903809206976520#heading-10">https://juejin.cn/post/6844903809206976520#heading-10</a> 可参考</li>
<li>共同点：都是改变this指向 </li>
<li>区别<ul>
<li>call 和 apply是立即执行的，而bind是返回一个新的函数，需要手动去调用</li>
<li>call可以传递多个参数，第一个参数和apply’一样，是用来替换的对象，后边是参数列表</li>
<li>apply最多智能有两个参数  （新this对象，数组argsArray）-&gt;  fun.apply(thisArg, [argsArray])</li>
</ul>
</li>
</ul>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><ul>
<li>改变this指向</li>
<li>函数立即执行，返回执行结果</li>
<li><a href="https://juejin.cn/post/6844903906279964686#heading-19">https://juejin.cn/post/6844903906279964686#heading-19</a> 可参考</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_call</span> = <span class="keyword">function</span>(<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  	<span class="comment">// 判断上下文对象</span></span><br><span class="line">    context = context ？<span class="title class_">Object</span>(context) : <span class="variable language_">window</span></span><br><span class="line">    <span class="comment">// 创造唯一key值，作为我们构造的context内部方法名</span></span><br><span class="line">    <span class="keyword">let</span> fn = <span class="title class_">Symbol</span>(<span class="string">&#x27;thisFn&#x27;</span>) </span><br><span class="line">     <span class="comment">// 1. 将fn作为属性添加到context上</span></span><br><span class="line">    context[fn] = <span class="variable language_">this</span> <span class="comment">// 隐式绑定，改变构造函数的调用者间接改变 this 指向</span></span><br><span class="line">    <span class="comment">// 2. 将挂载以后的方法调用</span></span><br><span class="line">    <span class="keyword">let</span> res = context[fn](...args)  <span class="comment">// 这里..args将args数组，变为参数列表，数组的扩展运算符</span></span><br><span class="line">    <span class="comment">// 3. 删除新添加的对象属性</span></span><br><span class="line">    <span class="keyword">delete</span> context[fn]</span><br><span class="line">    <span class="comment">// 4. 返回调用结果</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func.apply(thisArg, [argsArray])</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">thisArg, args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="title class_">Symbol</span>(<span class="string">&#x27;fn&#x27;</span>) <span class="comment">// 创建个独一无二的方法名</span></span><br><span class="line">    thisArg[fn] = <span class="variable language_">this</span> <span class="comment">// 方法变换执行对象</span></span><br><span class="line">    <span class="keyword">let</span> res = thisArg[fn](...args) </span><br><span class="line">    <span class="keyword">delete</span> thisArg[fn] <span class="comment">// 删除对象属性</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><ul>
<li>改变this指向</li>
<li>返回一个新函数</li>
<li>新函数可能被当做构造函数调用，函数可能有返回值</li>
<li>当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效</li>
<li>传递参数并柯里化</li>
<li><a href="https://www.jianshu.com/p/b540e1e17f54">https://www.jianshu.com/p/b540e1e17f54</a> 参考</li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/12">https://github.com/mqyqingfeng/Blog/issues/12</a>  冴羽</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// // ES2015 arguments是一个对象，类数组；</span></span><br><span class="line"><span class="comment">// const args = Array.from(arguments);</span></span><br><span class="line"><span class="comment">// const args = [...arguments];</span></span><br><span class="line"><span class="comment">// let new_array = old_array.concat(value1,value2,...)</span></span><br><span class="line"><span class="comment">// concat后面参数可以是数组，也可以是参数本身</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="variable language_">this</span> != <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;this is not a function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>) <span class="comment">// 第一个参数是this，截取掉</span></span><br><span class="line">    <span class="keyword">const</span> fNOP = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> fBound =  <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 返回一个绑定了this指向的方法，闭包</span></span><br><span class="line">        <span class="keyword">const</span> newArgs = args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        <span class="comment">// _self.call(context, ...args.concat(...arguments)) 参数为数组，用apply简单</span></span><br><span class="line">      	<span class="keyword">return</span> self.<span class="title function_">apply</span>(<span class="variable language_">this</span> instance <span class="keyword">of</span> fNOP ? <span class="variable language_">this</span> : context, newArgs)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.方法1 原型式继承</span></span><br><span class="line">    fNOP.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>(); <span class="comment">//绑定原型 原型式继承</span></span><br><span class="line">    <span class="comment">// 2. 方法2: fBound.prototype = Object.create(this.prototype)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去注释 double</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind2</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 判断调用bind的是否是函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;this is not a function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 保存当前环境上下文，取截取this后的传入参数</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span>  </span><br><span class="line">    <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> fNOP = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fBound = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> newArgs = args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">      <span class="comment">// 1.当作为构造函数 new操作的时候，this指向实例，将绑定函数的this指向该实例，可以让实例获得来自绑定函数的值</span></span><br><span class="line">      <span class="comment">// 2.当作为普通函数时，将绑定函数的this指向context</span></span><br><span class="line">      <span class="keyword">return</span> self.<span class="title function_">apply</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="variable language_">this</span> : context, newArgs)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.原型式继承</span></span><br><span class="line">    fNOP.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">    fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>()</span><br><span class="line">  <span class="comment">// 复制原函数的prototype给fBound， 一些情况下函数没有prototype，如箭头函数</span></span><br><span class="line">  <span class="comment">// fBound.prototype.__proto__ = (fNOP.prototype=this.prototype)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBound</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   fBound.prototype = this.prototype;</span></span><br><span class="line"><span class="comment">// 直接修改 fBound.prototype 的时候，也会直接修改绑定函数的 prototype</span></span><br></pre></td></tr></table></figure>

<h4 id="bind2"><a href="#bind2" class="headerlink" title="bind2"></a>bind2</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://jsgodroad.com/interview/js/#%E6%89%8B%E5%86%99%E9%A2%98</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">var</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">_this</span>(...args, ...<span class="variable language_">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _this.<span class="title function_">apply</span>(context, args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="🔥bind3-new-2021-12-13"><a href="#🔥bind3-new-2021-12-13" class="headerlink" title="🔥bind3 new 2021-12-13"></a>🔥bind3 new 2021-12-13</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">objThis, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;what is trying to be bound is not callable&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="variable language_">this</span> <span class="comment">// 保存源函数,以及参数</span></span><br><span class="line">    <span class="keyword">const</span> fBound = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> newArgs = args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        <span class="keyword">return</span> self.<span class="title function_">apply</span>(<span class="variable language_">this</span> <span class="keyword">instanceof</span> fBound ? <span class="variable language_">this</span> : objThis, newArgs)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修复函数没有prototype的情况 // 维护原型关系</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">        fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fBound</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// https://juejin.cn/post/6844903906279964686#heading-14</span></span><br></pre></td></tr></table></figure>



<h4 id="bind-polyfill-core-js"><a href="#bind-polyfill-core-js" class="headerlink" title="bind-polyfill-core-js"></a>bind-polyfill-core-js</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  Yes, it does work with `new (funcA.bind(thisArg, args))`</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span>) (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="title class_">ArrayPrototypeSlice</span> = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>;</span><br><span class="line">  <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span>(<span class="params">otherThis</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">      <span class="comment">// internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Function.prototype.bind - what is trying to be bound is not callable&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> baseArgs= <span class="title class_">ArrayPrototypeSlice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>, <span class="number">1</span>),</span><br><span class="line">        baseArgsLength = baseArgs.<span class="property">length</span>,</span><br><span class="line">        fToBind = <span class="variable language_">this</span>,</span><br><span class="line">        fNOP    = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">        fBound  = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">          baseArgs.<span class="property">length</span> = baseArgsLength; <span class="comment">// reset to default base arguments</span></span><br><span class="line">          baseArgs.<span class="property">push</span>.<span class="title function_">apply</span>(baseArgs, <span class="variable language_">arguments</span>);</span><br><span class="line">          <span class="keyword">return</span> fToBind.<span class="title function_">apply</span>(</span><br><span class="line">            <span class="comment">// 是否被new操作符调用，是的话就用新创建的this替换bind的this</span></span><br><span class="line">                 fNOP.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(<span class="variable language_">this</span>) ? <span class="variable language_">this</span> : otherThis, baseArgs</span><br><span class="line">          );</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">      <span class="comment">// Function.prototype doesn&#x27;t have a prototype property</span></span><br><span class="line">      fNOP.<span class="property"><span class="keyword">prototype</span></span> = <span class="variable language_">this</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止new了函数后改变原型导致原函数的原型被修改</span></span><br><span class="line">    fBound.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">fNOP</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>



<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><h4 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h4><ul>
<li>事件响应函数在一段时间后才执行,如果这段时间内再次调用,则重新计算。 在一定的时间间隔内,将多次触发变成一次触发</li>
</ul>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ol>
<li>限制鼠标连续点击（按钮提交等）</li>
<li>Scroll事件滚动防抖</li>
<li>搜索框输入查询</li>
<li>浏览器窗口缩放，resize事件</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://www.30secondsofcode.org/js/s/debounce 目前看见最简写法，best！</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">fn, ms = <span class="number">0</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> timeoutId</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123; </span><br><span class="line">    <span class="comment">// function(...args) rest参数 ，将args转为数组</span></span><br><span class="line">    <span class="comment">// 对比数组的扩展运算法 fn.call(obj,...args) 含义不一样, 将args转为参数列表</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timerId) <span class="comment">// 每次点击的时候清除上一个定时器，重新计时</span></span><br><span class="line">    timeoutId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,args), ms)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流  throttle"></a>节流  throttle</h4><ul>
<li>持续的触发事件,每隔一段时间, 只执行一次 ，减少一段时间的触发频率</li>
</ul>
<h5 id="时间戳版本"><a href="#时间戳版本" class="headerlink" title="时间戳版本"></a>时间戳版本</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, wait</span>) =&gt; &#123;</span><br><span class="line">  	<span class="keyword">let</span> pre = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// Date.now || + new Date() || new Date().getTime() || new Date().valueOf()</span></span><br><span class="line">      <span class="keyword">let</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">      <span class="keyword">if</span> (now - pre &gt; = wait) &#123;</span><br><span class="line">        <span class="comment">// apply第二个参数可以是数组，也可以是类数组对象</span></span><br><span class="line">        <span class="comment">// 所以写arguments没有问题！</span></span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,<span class="variable language_">arguments</span>)</span><br><span class="line">        pre = <span class="title class_">Date</span>.<span class="title function_">now</span>() <span class="comment">// 将当前时间记录， 作为下一个计时起点</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定时器版本"><a href="#定时器版本" class="headerlink" title="定时器版本"></a>定时器版本</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, wait</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> timerId </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timerId) &#123;</span><br><span class="line">      <span class="comment">// 这里箭头函数，this本身指向上层</span></span><br><span class="line">      timerId = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">        timerId = <span class="literal">null</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冴羽 https://github.com/mqyqingfeng/Blog/issues/26</span></span><br></pre></td></tr></table></figure>



<h2 id="deepClone深拷贝"><a href="#deepClone深拷贝" class="headerlink" title="deepClone深拷贝 !!!"></a>deepClone深拷贝 !!!</h2><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><ol>
<li>Object.assign()</li>
<li><code>...</code>扩展运算符 <strong><code>let cloneObj = &#123;...obj&#125;</code> <code>let newArr = [...arr]</code></strong></li>
<li>数组的Slice(), concat()</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">shallowClone</span> = obj =&gt; <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br></pre></td></tr></table></figure>

<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><h5 id="乞丐版"><a href="#乞丐版" class="headerlink" title="乞丐版"></a>乞丐版</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>( <span class="title class_">JSON</span>.<span class="title function_">stringify</span>( obj ) )</span><br></pre></td></tr></table></figure>

<ol>
<li>拷贝对象的值中如果有<code>函数</code>、<code>undefined</code>、<code>Symbol</code>，JSON.stringify序列化后的字符串中，这个键值对丢失</li>
<li>拷贝Date引用类型会变成字符串</li>
<li>拷贝RegExp会变成空对象 <code>&#123;&#125;</code></li>
<li>对象中含有 <code>NaN</code>、<code>Infinity</code> 会变成 <code>null</code></li>
<li>无法拷贝对象的原型链</li>
<li>无法拷贝不可枚举的属性 如Symbol</li>
<li>无法拷贝对象的循环引用 ， 即对象成环 <code>obj[key] = obj</code></li>
</ol>
<h5 id="🔥优化版"><a href="#🔥优化版" class="headerlink" title="🔥优化版"></a>🔥优化版</h5><ul>
<li><p>考虑 Date、RegExp类型， 直接生成一个新的实例返回</p>
</li>
<li><p>考虑数组  <code>let target = Array.isArray(obj)? [] : &#123;&#125;</code></p>
</li>
<li><p>考虑循环引用  利用WeakMap作为hash表， 检测到对象已存在于哈希表中，取出该值返回即可</p>
</li>
<li><p>针对不可枚举属性以及 Symbol 类型，使用 Reflect.ownKeys()</p>
</li>
<li><p>函数部分太复杂，函数的原型，多层柯里化等</p>
</li>
<li><p>针对Map, Set, Error等，Object.getOwnPropertyDescriptors(obj) 也不考虑</p>
</li>
<li><p>递归爆栈问题，改用循环解决，广度优先</p>
</li>
<li><p> <a href="https://segmentfault.com/a/1190000016672263">深拷贝的终极探索（99%的人都不知道）</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6844903929705136141#heading-4">如何写出一个惊艳面试官的深拷贝?</a> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">RangeError</span>: <span class="title class_">Maximum</span> call stack size exceeded</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测对象 </span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isObject</span> = (<span class="params">obj</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>  <span class="comment">// !!obj</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">deepClone</span> = (<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 值类型 直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(obj)) <span class="keyword">return</span> obj</span><br><span class="line">  <span class="comment">// Date, RegExp  constructor容易被修改丢失，被认为不安全，不推荐作为判断</span></span><br><span class="line">  <span class="comment">// instanceof好一些</span></span><br><span class="line"><span class="comment">//  if (obj.constructor === Date) return new Date(obj)</span></span><br><span class="line"><span class="comment">//  if (obj.constructor === RegExp) return new RegExp(obj)</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(obj)</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RegExp</span>(obj)</span><br><span class="line">  <span class="comment">// 解决循环引用，查哈希表</span></span><br><span class="line">  <span class="keyword">if</span> (hash.<span class="title function_">has</span>(obj)) <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj)</span><br><span class="line"><span class="comment">//     let allDesc = Object.getOwnPropertyDescriptors(obj)</span></span><br><span class="line"><span class="comment">//     let target = Object.create(Object.getPrototypeOf(obj),allDesc)</span></span><br><span class="line">  <span class="keyword">let</span> target = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125; <span class="comment">// 考虑数组</span></span><br><span class="line">  hash.<span class="title function_">set</span>(obj, target)</span><br><span class="line">  </span><br><span class="line">  <span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(obj[key])) &#123;</span><br><span class="line">      target[key] = <span class="title function_">deepClone</span>(obj[key], hash)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target[key] = obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><a href="https://yanhaijing.com/javascript/2018/10/10/clone-deep/">深拷贝的终极探索</a> </li>
</ol>
<h2 id="实现-5-add-3-minus-2-功能"><a href="#实现-5-add-3-minus-2-功能" class="headerlink" title="实现 (5).add(3).minus(2) 功能"></a>实现 (5).add(3).minus(2) 功能</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> number !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请输入数字～&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">valueOf</span>() + n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">minus</span> = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> number !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;请输入数字～&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// return this - n </span></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">valueOf</span>() - n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// (5).add(3).minus(2)</span></span><br></pre></td></tr></table></figure>



<h2 id="如何求数组最大值和最小值"><a href="#如何求数组最大值和最小值" class="headerlink" title="如何求数组最大值和最小值"></a>如何求数组最大值和最小值</h2><ol>
<li>循环后Math.max</li>
<li>reduce</li>
<li>sort排序后取最后</li>
<li>ES6 … + Math.max</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Math.max</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">23</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    result =  <span class="title class_">Math</span>.<span class="title function_">max</span>(result, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line"><span class="comment">// 2. reduce</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">23</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">max</span>(<span class="params">prev, next</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(prev, next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">reduce</span>(max));</span><br><span class="line"><span class="comment">// 3. sort</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">23</span>];</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;<span class="keyword">return</span> a - b;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[arr.<span class="property">length</span> - <span class="number">1</span>])</span><br><span class="line"><span class="comment">// 4. ES6 ...</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">23</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="literal">null</span>, arr))</span><br></pre></td></tr></table></figure>



<h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><ul>
<li>双重for循环</li>
<li>new Set</li>
<li>indexOf</li>
<li>array.filter + indexOf</li>
<li>sort排序 + 相邻元素对比</li>
<li>Object 键值对 obj.hasOwnProperty</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0. 双重for循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Set集合，不能有重复值</span></span><br><span class="line"><span class="keyword">const</span> newArr2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr))</span><br><span class="line"><span class="comment">// 简化</span></span><br><span class="line"><span class="keyword">const</span> newArr = [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. indexOf</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resetArr</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="title function_">indexOf</span>(item) === -<span class="number">1</span>) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1</span></span><br><span class="line"><span class="comment">// filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. array.filter + indexOf</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">unique</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> res =  arr.<span class="title function_">filter</span>(<span class="function">(<span class="params">item,index</span>) =&gt;</span> &#123;</span><br><span class="line">    	<span class="comment">// 如果第一次出现，相等</span></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">indexOf</span>(item) === index </span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. sort排序后相邻元素对比</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;type error!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    arr = arr.<span class="title function_">sort</span>()</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="comment">// i从1开始算 arr[i-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] !== arr[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5.obj.hasOwnProperty</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">resetArr</span>(arr)) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="comment">// https://github.com/mqyqingfeng/Blog/issues/27</span></span><br></pre></td></tr></table></figure>

<h2 id="数组扁平化-flatten"><a href="#数组扁平化-flatten" class="headerlink" title="数组扁平化 flatten"></a>数组扁平化 flatten</h2><p><a href="https://juejin.cn/post/6844904025993773063">面试官连环追问：数组拍平（扁平化） flat 方法实现</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line">console.log(flatten(arr)) // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<h3 id="🔥循环递归"><a href="#🔥循环递归" class="headerlink" title="🔥循环递归"></a>🔥循环递归</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法 1</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr[i])) &#123;</span><br><span class="line">            result = result.<span class="title function_">concat</span>(<span class="title function_">flatten</span>(arr[i]))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>如果数组元素都是Number, 可以使用；但不推荐这种 toString+split方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]].<span class="title function_">toString</span>() <span class="comment">// &quot;1,2,3,4&quot;</span></span><br><span class="line"><span class="comment">// 场景却非常有限，如果数组是 [1, &#x27;1&#x27;, 2, &#x27;2&#x27;] 此方法不适合</span></span><br><span class="line"><span class="comment">// 扁平化不改变原数据类型</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>).<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> +item <span class="comment">//转为Number</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr))</span><br></pre></td></tr></table></figure>

<h3 id="🔥用reduce实现flat"><a href="#🔥用reduce实现flat" class="headerlink" title="🔥用reduce实现flat"></a>🔥用reduce实现flat</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法3</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">prev, next</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> prev.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(next) ? <span class="title function_">flatten</span>(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">flatten</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> pre.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur) ? <span class="title function_">flatten</span>(cur) : cur)</span><br><span class="line">  &#125;,[])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 理解 </span></span><br><span class="line"><span class="comment">// var arr = [2, [3, 4]];</span></span><br><span class="line"><span class="comment">// pre  cur</span></span><br><span class="line"><span class="comment">// []   2       0    [2]</span></span><br><span class="line"><span class="comment">// [2]  [3,4]   1    [2] wait </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// []   3       0    [3]</span></span><br><span class="line"><span class="comment">// [3]  4       1    [3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [2]  [3,4]       [2,3,4]</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6-…"><a href="#ES6-…" class="headerlink" title="ES6 …"></a>ES6 …</h3><p>==[].concat(…arr)==</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([].<span class="title function_">concat</span>(...arr)); <span class="comment">// [1, 2, [3, 4]]</span></span><br><span class="line"><span class="comment">// 这时，只可以扁平一层，顺着这个方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法4</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatten</span>(<span class="params">arr</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item))) &#123;</span><br><span class="line">        arr = [].<span class="title function_">concat</span>(...arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatten</span>(arr))</span><br></pre></td></tr></table></figure>

<h2 id="🔥柯里化-curry"><a href="#🔥柯里化-curry" class="headerlink" title="🔥柯里化 curry"></a>🔥柯里化 curry</h2><p>柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">curry</span> = (<span class="params">fn, ...args</span>) =&gt;&#123;</span><br><span class="line">  <span class="comment">// 当参数与fn参数相同，则直接执行函数 fn.length 形参个数</span></span><br><span class="line">		<span class="keyword">if</span> (args.<span class="property">length</span> &gt;= fn.<span class="property">length</span>) <span class="keyword">return</span> <span class="title function_">fn</span>(...args)</span><br><span class="line">  <span class="comment">// 否则返回函数，合并参数，并继续自动柯里化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">curry</span>(fn, ...args, ...args2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数组合-compose"><a href="#函数组合-compose" class="headerlink" title="函数组合 compose"></a>函数组合 compose</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// redux中的实现 不一定准确 ，待整理</span></span><br><span class="line"><span class="comment">// https://github.com/mqyqingfeng/Blog/issues/45</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">...funcs</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (funcs.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> funcs.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title function_">a</span>(<span class="title function_">b</span>(...args)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h2><p><a href="https://juejin.cn/post/7031322059414175774#heading-16">https://juejin.cn/post/7031322059414175774#heading-16</a></p>
<h2 id="千位分隔符"><a href="#千位分隔符" class="headerlink" title="千位分隔符"></a>千位分隔符</h2><p><a href="https://juejin.cn/post/6844903911686406158#heading-19">https://juejin.cn/post/6844903911686406158#heading-19</a></p>
<h2 id="异步控制并发数"><a href="#异步控制并发数" class="headerlink" title="异步控制并发数"></a>异步控制并发数</h2><h2 id="ES5继承（寄生组合继承）"><a href="#ES5继承（寄生组合继承）" class="headerlink" title="ES5继承（寄生组合继承）"></a>ES5继承（寄生组合继承）</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://github.com/mqyqingfeng/Blog">冴羽的博客</a></li>
<li><a href="https://juejin.cn/post/7000374304727089159">前端必刷手写题系列 [22]</a></li>
</ol>
]]></content>
      <categories>
        <category>八股文</category>
      </categories>
  </entry>
  <entry>
    <title>🎉🎉博客开通啦🎉🎉</title>
    <url>/2023/01/08/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="CLHaoer-前端小破站🐱‍🏍🐱‍🏍🐱‍🏍"><a href="#CLHaoer-前端小破站🐱‍🏍🐱‍🏍🐱‍🏍" class="headerlink" title="CLHaoer 前端小破站🐱‍🏍🐱‍🏍🐱‍🏍"></a>CLHaoer 前端小破站🐱‍🏍🐱‍🏍🐱‍🏍</h1><ul>
<li>👨‍💻刚开始的前端小人物</li>
<li>🎈黑马学习ing</li>
</ul>
]]></content>
      <categories>
        <category>日常哔哔</category>
      </categories>
  </entry>
  <entry>
    <title>面试题📚</title>
    <url>/2023/01/10/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="前端面试宝典合集📚📚📚"><a href="#前端面试宝典合集📚📚📚" class="headerlink" title="前端面试宝典合集📚📚📚"></a>前端面试宝典合集📚📚📚</h2><ul>
<li><p><a href="https://clhaoer.github.io/pdf/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8V3.0.pdf">前端面试v3.0</a></p>
</li>
<li><p><a href="https://clhaoer.github.io/pdf/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8V4.0.pdf">前端面试v4.0</a></p>
</li>
<li><p><a href="https://clhaoer.github.io/pdf/%E9%87%8D%E7%82%B9%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E6%88%90%E9%83%BD%EF%BC%89.pdf">重点面试题（成都）</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>八股文</category>
      </categories>
  </entry>
  <entry>
    <title>深入响应式原理</title>
    <url>/2023/02/16/%E6%B7%B1%E5%85%A5%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="变化侦测"><a href="#变化侦测" class="headerlink" title="变化侦测"></a>变化侦测</h1><h2 id="什么是变化侦测"><a href="#什么是变化侦测" class="headerlink" title="什么是变化侦测"></a>什么是变化侦测</h2><p>变化侦测就是追踪状态，或者说是追踪数据的变化，一旦数据发生了变化，就要去更新视图。</p>
<p>变化侦测可不是个新名词，它在目前的前端三大框架中均有涉及。在<code>Angular</code>中是通过脏值检查流程来实现变化侦测；在<code>React</code>是通过对比虚拟<code>DOM</code>来实现变化侦测，而在<code>Vue</code>中也有自己的一套变化侦测实现机制。</p>
<p>那<code>Vue</code>是怎么知道<code>state</code>（状态）变化了呢？换句话说，数据变化了是怎么通知给<code>Vue</code>呢？</p>
<h2 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h2><blockquote>
<p>JS中，如何侦测一个对象的变化？    (对象的属性值改变)</p>
</blockquote>
<h3 id="ES5-gt-Object-defineProperty"><a href="#ES5-gt-Object-defineProperty" class="headerlink" title="ES5 =&gt;  Object.defineProperty"></a>ES5 =&gt;  Object.defineProperty</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>)&#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="attr">configurable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">enumerable</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="comment">// 读obj.key触发getter</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getter触发&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span>(<span class="params">newVal</span>)&#123;</span><br><span class="line">            <span class="comment">// 写obj.key触发setter</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setter触发&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> (val === newVal) <span class="keyword">return</span> </span><br><span class="line">            val = newVal</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装了这个代码之后，对一个对象的属性变化，我们就可以做一些监听了</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">defineReactive</span>(obj,<span class="string">&#x27;age&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>封装好defineReactive之后，</p>
<p>每当从data的key中读取数据时，get函数被触发；</p>
<p>每当往data的key中 设置数据时，set函数被触发 </p>
</blockquote>
<h3 id="ES6-gt-Proxy"><a href="#ES6-gt-Proxy" class="headerlink" title="ES6 =&gt;  Proxy"></a>ES6 =&gt;  Proxy</h3><h2 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h2><p> Vue.js 实现响应式的核心是利用了 ES5 的 <code>Object.defineProperty</code>   - <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">link-MDN</a></p>
<blockquote>
<p> 作用：在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    obj: 目标对象</span></span><br><span class="line"><span class="comment">    prop: 需要操作的目标对象的属性名</span></span><br><span class="line"><span class="comment">    descriptor: 描述符</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    return value 传入的对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, prop/key, descriptor)</span><br></pre></td></tr></table></figure>

<p><code>obj</code> 是要在其上定义属性的对象；<code>prop</code> 是要定义或修改的属性的名称；<code>descriptor</code> 是将被定义或修改的属性描述符。</p>
<p>descriptor的一些属性，简单介绍几个属性，具体可以参考 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN 文档</a>。</p>
<ul>
<li><code>enumerable</code>，控制属性是否可枚举，默认 false。</li>
<li><code>configurable</code>，属性描述符是否可以修改，属性是否可以删除，默认 false。</li>
<li><code>get</code>，获取属性的方法。</li>
<li><code>set</code>，设置属性的方法。</li>
</ul>
<p>这里我们最关心的是 <code>get</code> 和 <code>set</code>，</p>
<ul>
<li><p><code>get</code> 是一个给属性提供的 getter 方法，当我们访问了该属性的时候会触发 getter 方法；</p>
</li>
<li><p><code>set</code> 是一个给属性提供的 setter 方法，当我们对该属性做修改的时候会触发 setter 方法。</p>
</li>
</ul>
<p>一旦对象拥有了 getter 和 setter，我们可以简单地把这个对象称为<strong>响应式对象</strong>。</p>
<h2 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h2><blockquote>
<p><strong>src\core\observer\index.ts</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params"></span></span><br><span class="line"><span class="params">  obj: object,</span></span><br><span class="line"><span class="params">  key: string,</span></span><br><span class="line"><span class="params">  val?: any,</span></span><br><span class="line"><span class="params">  customSetter?: <span class="built_in">Function</span> | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  shallow?: boolean,</span></span><br><span class="line"><span class="params">  mock?: boolean</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/*!! 在定义一个dep对象，getter中进行依赖收集，闭包*/</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出某个属性的descriptor描述对象</span></span><br><span class="line">  <span class="keyword">const</span> property = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.<span class="property">configurable</span> === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果这个属性中已经预设了getter以及setter函数则取出来</span></span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.<span class="property">get</span></span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.<span class="property">set</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (!getter || setter) &amp;&amp;</span><br><span class="line">    (val === <span class="variable constant_">NO_INITIAL_VALUE</span> || <span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//!! /*对象的子对象递归进行observe并返回子节点的Observer对象*/</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(val, <span class="literal">false</span>, mock)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Object.defineProperty  ==&gt; 核心的API 这个！！！ initData ==&gt; </span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="comment">// 如果原本对象这个属性拥有getter方法则执行</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 依赖收集 ---start </span></span><br><span class="line">      <span class="comment">// Dep.target当前渲染watcher</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          dep.<span class="title function_">depend</span>(&#123;</span><br><span class="line">            <span class="attr">target</span>: obj,</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>,</span><br><span class="line">            key</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">/*进行依赖收集*/</span></span><br><span class="line">          <span class="comment">/*实际上调用了 Dep.target.addDep(this)这个方法*/</span>  </span><br><span class="line">          <span class="comment">// addDep实际上是watcher定义的</span></span><br><span class="line">          dep.<span class="title function_">depend</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          <span class="comment">/*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/</span></span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">              <span class="comment">/*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/</span></span><br><span class="line">            <span class="title function_">dependArray</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 依赖收集 --- end</span></span><br><span class="line">       <span class="comment">// return value</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">isRef</span>(value) &amp;&amp; !shallow ? value.<span class="property">value</span> : value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="comment">/*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/</span></span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">hasChanged</span>(value, newVal)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; customSetter) &#123;</span><br><span class="line">        <span class="title function_">customSetter</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        <span class="comment">/*如果原本对象的属性拥有setter方法则执行setter*/</span></span><br><span class="line">        setter.<span class="title function_">call</span>(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getter) &#123;</span><br><span class="line">        <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!shallow &amp;&amp; <span class="title function_">isRef</span>(value) &amp;&amp; !<span class="title function_">isRef</span>(newVal)) &#123;</span><br><span class="line">        value.<span class="property">value</span> = newVal</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="comment">/*新的值需要重新进行observe，保证数据响应式*/</span></span><br><span class="line">       <span class="comment">// childOb = observe(newVal)</span></span><br><span class="line">      childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(newVal, <span class="literal">false</span>, mock)</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        dep.<span class="title function_">notify</span>(&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>,</span><br><span class="line">          <span class="attr">target</span>: obj,</span><br><span class="line">          key,</span><br><span class="line">          <span class="attr">newValue</span>: newVal,</span><br><span class="line">          <span class="attr">oldValue</span>: value</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 通知依赖更新，更新视图</span></span><br><span class="line">        <span class="comment">// 通知所有用到data中变化的那个属性的，所有组件 都更新视图 </span></span><br><span class="line">        <span class="comment">// 依赖收集：收集用到了data某个属性的所有组件 </span></span><br><span class="line">        <span class="comment">/*dep对象通知所有的观察者*/</span></span><br><span class="line">        dep.<span class="title function_">notify</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dep</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>响应式对象的核心是利用Object.defineProperty给对象的属性添加 getter 和 setter, </p>
</li>
<li><p>Vue会把props，data变成响应式对象，在定义响应式对象的过程中，如果data对象子属性也为对象，则递归的把该对象的子对象也变为响应式的。</p>
</li>
</ol>
</blockquote>
<h1 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h1><blockquote>
<p>Qestion: </p>
<ol>
<li>什么是依赖收集？</li>
<li>在哪里做的依赖收集？</li>
<li>收集的依赖放到存到了哪里？</li>
</ol>
</blockquote>
<h2 id="什么是依赖收集"><a href="#什么是依赖收集" class="headerlink" title="什么是依赖收集"></a>什么是依赖收集</h2><p>data中的数据变为的可观测以后，我们就能知道数据什么时候发生了变化，那么当数据发生变化时，我们去通知视图更新就好了。</p>
<p>那么问题又来了，视图那么大，组件那么多，我们到底该通知谁去变化（哪个组件更新视图）？总不能一个数据变化了，把整个视图全部更新一遍吧，这样显然是不合理的。大家肯定会想到，视图里谁用到了这个数据就更新谁呗。是滴，尤大大也是这么想的~~</p>
<p>视图里谁用到了这个数据就更新谁，我们换个优雅说法：我们把”谁用到了这个数据”称为”谁依赖了这个数据”, =&gt; <code>哪些地方依赖了data中的数据</code>?</p>
<blockquote>
<p>我们把用到data中数据的地方，都叫做依赖，比如一个组件template中p标签里渲染了,  那么这个组件的这个dom元素就依赖了msg这个数据，但是在Vue2中，我们把用到数据的这个组件叫做 msg数据 的 依赖。</p>
</blockquote>
<ul>
<li>vue1.x，细粒度依赖，用到数据的 DOM 都是依赖；</li>
<li>Vue2.x，中等粒度依赖，用到数据的 <code>组件</code> 是依赖；</li>
</ul>
<p>我们给每个数据都建一个依赖数组(因为一个数据可能被多处使用)，谁依赖了这个数据(即谁用到了这个数据)我们就把谁放入这个依赖数组中，那么当这个数据发生变化的时候，我们就去它对应的依赖数组中，把每个依赖都通知一遍，告诉他们：”你们依赖的数据变啦，你们该更新啦！”。这个过程就是依赖收集。</p>
<h2 id="如何收集依赖"><a href="#如何收集依赖" class="headerlink" title="如何收集依赖"></a>如何收集依赖</h2><h2 id="Dep类"><a href="#Dep类" class="headerlink" title="Dep类"></a>Dep类</h2><blockquote>
<p> <strong>src\core\observer\dep.ts</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">&#x27;../config&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">DebuggerOptions</span>, <span class="title class_">DebuggerEventExtraInfo</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;v3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">pendingCleanupDeps</span>: <span class="title class_">Dep</span>[] = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">cleanupDeps</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pendingCleanupDeps.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = pendingCleanupDeps[i]</span><br><span class="line">    dep.<span class="property">subs</span> = dep.<span class="property">subs</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">s</span> =&gt;</span> s)</span><br><span class="line">    dep.<span class="property">_pending</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  pendingCleanupDeps.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">DepTarget</span> <span class="keyword">extends</span> <span class="title class_">DebuggerOptions</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: number</span><br><span class="line">  <span class="title function_">addDep</span>(<span class="attr">dep</span>: <span class="title class_">Dep</span>): <span class="keyword">void</span></span><br><span class="line">  <span class="title function_">update</span>(): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A dep is an observable that can have multiple</span></span><br><span class="line"><span class="comment"> * directives subscribing to it.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@internal</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立数据和watcher之前的桥梁</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> target?: <span class="title class_">DepTarget</span> | <span class="literal">null</span></span><br><span class="line">  <span class="attr">id</span>: number</span><br><span class="line">  <span class="attr">subs</span>: <span class="title class_">Array</span>&lt;<span class="title class_">DepTarget</span> | <span class="literal">null</span>&gt;</span><br><span class="line">  <span class="comment">// pending subs cleanup</span></span><br><span class="line">  _pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = uid++</span><br><span class="line">    <span class="comment">/* 订阅数据变化的watcher会保存到subs数组中 */</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">addSub</span>(<span class="params">sub: DepTarget</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">removeSub</span>(<span class="params">sub: DepTarget</span>) &#123;</span><br><span class="line">    <span class="comment">// #12696 deps with massive amount of subscribers are extremely slow to</span></span><br><span class="line">    <span class="comment">// clean up in Chromium</span></span><br><span class="line">    <span class="comment">// to workaround this, we unset the sub for now, and clear them on</span></span><br><span class="line">    <span class="comment">// next scheduler flush.</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>[<span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">indexOf</span>(sub)] = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_pending</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">_pending</span> = <span class="literal">true</span></span><br><span class="line">      pendingCleanupDeps.<span class="title function_">push</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">depend</span>(<span class="params">info?: DebuggerEventExtraInfo</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      <span class="comment">// 调用watcher的addDep方法</span></span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>)</span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; info &amp;&amp; <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="property">onTrack</span>) &#123;</span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">onTrack</span>(&#123;</span><br><span class="line">          <span class="attr">effect</span>: <span class="title class_">Dep</span>.<span class="property">target</span>,</span><br><span class="line">          ...info</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">notify</span>(<span class="params">info?: DebuggerEventExtraInfo</span>) &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">s</span> =&gt;</span> s) <span class="keyword">as</span> <span class="title class_">DepTarget</span>[]</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; !config.<span class="property">async</span>) &#123;</span><br><span class="line">      <span class="comment">// subs aren&#x27;t sorted in scheduler if not running async</span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">      <span class="comment">// order</span></span><br><span class="line">      subs.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">id</span> - b.<span class="property">id</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> sub = subs[i]</span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; info) &#123;</span><br><span class="line">        sub.<span class="property">onTrigger</span> &amp;&amp;</span><br><span class="line">          sub.<span class="title function_">onTrigger</span>(&#123;</span><br><span class="line">            <span class="attr">effect</span>: subs[i],</span><br><span class="line">            ...info</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      sub.<span class="title function_">update</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The current target watcher being evaluated.</span></span><br><span class="line"><span class="comment">// This is globally unique because only one watcher</span></span><br><span class="line"><span class="comment">// can be evaluated at a time.</span></span><br><span class="line"><span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">targetStack</span>: <span class="title class_">Array</span>&lt;<span class="title class_">DepTarget</span> | <span class="literal">null</span> | <span class="literal">undefined</span>&gt; = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">pushTarget</span>(<span class="params">target?: DepTarget | <span class="literal">null</span></span>) &#123;</span><br><span class="line">  <span class="comment">// targetStack 嵌套组件</span></span><br><span class="line">  targetStack.<span class="title function_">push</span>(target)</span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">popTarget</span>(<span class="params"></span>) &#123;</span><br><span class="line">  targetStack.<span class="title function_">pop</span>()</span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = targetStack[targetStack.<span class="property">length</span> - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Watcher类"><a href="#Watcher类" class="headerlink" title="Watcher类"></a>Watcher类</h2><blockquote>
<p><strong>src\core\observer\watcher.ts</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> implements <span class="title class_">DepTarget</span> &#123;</span><br><span class="line">  vm?: <span class="title class_">Component</span> | <span class="literal">null</span></span><br><span class="line">  <span class="attr">expression</span>: string</span><br><span class="line">  <span class="attr">cb</span>: <span class="title class_">Function</span></span><br><span class="line">  <span class="attr">id</span>: number</span><br><span class="line">  <span class="attr">deep</span>: boolean</span><br><span class="line">  <span class="attr">user</span>: boolean</span><br><span class="line">  <span class="attr">lazy</span>: boolean</span><br><span class="line">  <span class="attr">sync</span>: boolean</span><br><span class="line">  <span class="attr">dirty</span>: boolean</span><br><span class="line">  <span class="attr">active</span>: boolean</span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Dep</span>&gt;</span><br><span class="line">  <span class="attr">newDeps</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Dep</span>&gt;</span><br><span class="line">  <span class="attr">depIds</span>: <span class="title class_">SimpleSet</span></span><br><span class="line">  <span class="attr">newDepIds</span>: <span class="title class_">SimpleSet</span></span><br><span class="line">  before?: <span class="title class_">Function</span></span><br><span class="line">  onStop?: <span class="title class_">Function</span></span><br><span class="line">  noRecurse?: boolean</span><br><span class="line">  <span class="attr">getter</span>: <span class="title class_">Function</span></span><br><span class="line">  <span class="attr">value</span>: any</span><br><span class="line">  <span class="attr">post</span>: boolean</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dev only</span></span><br><span class="line">  onTrack?: (<span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="keyword">void</span>) | <span class="literal">undefined</span></span><br><span class="line">  onTrigger?: (<span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="keyword">void</span>) | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">    vm: Component | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    expOrFn: string | (() =&gt; any),</span></span><br><span class="line"><span class="params">    cb: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    options?: WatcherOptions | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">    isRenderWatcher?: boolean</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="title function_">recordEffectScope</span>(</span><br><span class="line">      <span class="variable language_">this</span>,</span><br><span class="line">      <span class="comment">// if the active effect scope is manually created (not a component scope),</span></span><br><span class="line">      <span class="comment">// prioritize it</span></span><br><span class="line">      activeEffectScope &amp;&amp; !activeEffectScope.<span class="property">_vm</span></span><br><span class="line">        ? activeEffectScope</span><br><span class="line">        : vm</span><br><span class="line">        ? vm.<span class="property">_scope</span></span><br><span class="line">        : <span class="literal">undefined</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> ((<span class="variable language_">this</span>.<span class="property">vm</span> = vm) &amp;&amp; isRenderWatcher) &#123;</span><br><span class="line">      vm.<span class="property">_watcher</span> = <span class="variable language_">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deep</span> = !!options.<span class="property">deep</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">user</span> = !!options.<span class="property">user</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">lazy</span> = !!options.<span class="property">lazy</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">sync</span> = !!options.<span class="property">sync</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">before</span> = options.<span class="property">before</span></span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onTrack</span> = options.<span class="property">onTrack</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onTrigger</span> = options.<span class="property">onTrigger</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deep</span> = <span class="variable language_">this</span>.<span class="property">user</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> = <span class="variable language_">this</span>.<span class="property">sync</span> = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">active</span> = <span class="literal">true</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">post</span> = <span class="literal">false</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> <span class="comment">// for lazy watchers  ==&gt; computed</span></span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="comment">// end</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">expression</span> = __DEV__ ? expOrFn.<span class="title function_">toString</span>() : <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">     <span class="comment">// 如果传入的第二个参数是一个函数，updateComponent哪里</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isFunction</span>(expOrFn)) &#123;</span><br><span class="line">      <span class="comment">// 如果是一个函数，把这个函数放到watcher实例对象的getter属性上</span></span><br><span class="line">        <span class="comment">/*把表达式expOrFn解析成getter*/</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = <span class="title function_">parsePath</span>(expOrFn)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> ? <span class="literal">undefined</span> : <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Dep类中定义</span></span><br><span class="line">    <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span>.<span class="property">vm</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// try-catch-finally =&gt; 重要的是try</span></span><br><span class="line">      <span class="comment">// 这里的调用getter，实际上是调用updateComponent方法</span></span><br><span class="line">      value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="attr">e</span>: any) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">user</span>) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deep</span>) &#123;</span><br><span class="line">        <span class="title function_">traverse</span>(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">popTarget</span>()</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add a dependency to this directive.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">addDep</span>(<span class="params">dep: Dep</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.<span class="property">id</span></span><br><span class="line">    <span class="comment">// 判断newDepIds中没有没</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">      <span class="comment">// 没有就添加id，并push dep到DepDes中</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">add</span>(id)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="title function_">push</span>(dep)</span><br><span class="line">      <span class="comment">// 如果depIds中也没有</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">depIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">         <span class="comment">// Dep类中的addSub方法，把这个watcher实例添加到Dep类的subs中</span></span><br><span class="line">        dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clean up for dependency collection.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">cleanupDeps</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="variable language_">this</span>.<span class="property">deps</span>[i]</span><br><span class="line">      <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(dep.<span class="property">id</span>)) &#123;</span><br><span class="line">        dep.<span class="title function_">removeSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">tmp</span>: any = <span class="variable language_">this</span>.<span class="property">depIds</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="variable language_">this</span>.<span class="property">newDepIds</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span> = tmp</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">clear</span>()</span><br><span class="line">    tmp = <span class="variable language_">this</span>.<span class="property">deps</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span> = <span class="variable language_">this</span>.<span class="property">newDeps</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span> = tmp</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Subscriber interface.</span></span><br><span class="line"><span class="comment">   * Will be called when a dependency changes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">lazy</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sync</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">run</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">queueWatcher</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Scheduler job interface.</span></span><br><span class="line"><span class="comment">   * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">active</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="variable language_">this</span>.<span class="property">value</span> ||</span><br><span class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">        <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">        <span class="comment">// have mutated.</span></span><br><span class="line">        <span class="title function_">isObject</span>(value) ||</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">deep</span></span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// set new value</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">user</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> info = <span class="string">`callback for watcher &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.expression&#125;</span>&quot;`</span></span><br><span class="line">          <span class="title function_">invokeWithErrorHandling</span>(</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">cb</span>,</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">vm</span>,</span><br><span class="line">            [value, oldValue],</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">vm</span>,</span><br><span class="line">            info</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">cb</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the value of the watcher.</span></span><br><span class="line"><span class="comment">   * This only gets called for lazy watchers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">evaluate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Depend on all deps collected by this watcher.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deps</span>[i].<span class="title function_">depend</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Remove self from all dependencies&#x27; subscriber list.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">teardown</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">vm</span> &amp;&amp; !<span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">_isBeingDestroyed</span>) &#123;</span><br><span class="line">      <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">_scope</span>.<span class="property">effects</span>, <span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">active</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span></span><br><span class="line">      <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">deps</span>[i].<span class="title function_">removeSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">active</span> = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">onStop</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">onStop</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件的watcher跟计算属性以及watch是不一样的一个watcher ， 是不同的watcher实例</p>
<h2 id="Observer类"><a href="#Observer类" class="headerlink" title="Observer类"></a>Observer类</h2><blockquote>
<p><strong>src\core\observer\index.ts</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="attr">dep</span>: <span class="title class_">Dep</span></span><br><span class="line">  <span class="attr">vmCount</span>: number <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">public value: any, public shallow = <span class="literal">false</span>, public mock = <span class="literal">false</span></span>) &#123;</span><br><span class="line">    <span class="comment">// this.value = value</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dep</span> = mock ? mockDep : <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vmCount</span> = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 将Observer实例挂载到data的__ob__属性上，</span></span><br><span class="line">    <span class="comment">// 相当于是给对象是否做了响应式打了一个标记，在调用observe的时候，会判断是否有这个标记</span></span><br><span class="line">    <span class="comment">// 如果对一个对象做过了响应式处理了，就不需要再做一遍</span></span><br><span class="line">    <span class="title function_">def</span>(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">          <span class="comment">/* eslint-disable no-proto */</span></span><br><span class="line">          ;(value <span class="keyword">as</span> any).<span class="property">__proto__</span> = arrayMethods</span><br><span class="line">          <span class="comment">/* eslint-enable no-proto */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = arrayKeys.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> key = arrayKeys[i]</span><br><span class="line">            <span class="title function_">def</span>(value, key, arrayMethods[key])</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!shallow) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">observeArray</span>(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 遍历对象上的每个key(属性)，将它们转为带有getter和setter的属性，</span></span><br><span class="line"><span class="comment">       * 这个方法只有当value是对象的时候才会执行，（原来2.6的版本是写的walk方法）</span></span><br><span class="line"><span class="comment">       */</span> </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Walk through all properties and convert them into</span></span><br><span class="line"><span class="comment">       * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">       * value type is Object.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(value)</span><br><span class="line">      <span class="comment">// data里面 可能有很多的属性 ，for循环，对每一个key都做响应式处理</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> key = keys[i]</span><br><span class="line">        <span class="comment">// 做响应式处理~~~ defineReactive</span></span><br><span class="line">        <span class="title function_">defineReactive</span>(value, key, <span class="variable constant_">NO_INITIAL_VALUE</span>, <span class="literal">undefined</span>, shallow, mock)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">observeArray</span>(<span class="params">value: any[]</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = value.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="title function_">observe</span>(value[i], <span class="literal">false</span>, <span class="variable language_">this</span>.<span class="property">mock</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="arrayMethods"><a href="#arrayMethods" class="headerlink" title="arrayMethods"></a>arrayMethods</h2><blockquote>
<p>src\core\observer\array.ts</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="title class_">Object</span>.<span class="title function_">create</span>(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="observer方法"><a href="#observer方法" class="headerlink" title="observer方法"></a>observer方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempt to create an observer instance for a value,</span></span><br><span class="line"><span class="comment"> * returns the new observer if successfully observed,</span></span><br><span class="line"><span class="comment"> * or the existing observer if the value already has one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value: any,</span></span><br><span class="line"><span class="params">  shallow?: boolean,</span></span><br><span class="line"><span class="params">  ssrMockReactivity?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Observer</span> | <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; <span class="title function_">hasOwn</span>(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.<span class="property">__ob__</span> <span class="keyword">instanceof</span> <span class="title class_">Observer</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.<span class="property">__ob__</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    (ssrMockReactivity || !<span class="title function_">isServerRendering</span>()) &amp;&amp;</span><br><span class="line">    (<span class="title function_">isArray</span>(value) || <span class="title function_">isPlainObject</span>(value)) &amp;&amp;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(value) &amp;&amp;</span><br><span class="line">    !value.<span class="property">__v_skip</span> <span class="comment">/* ReactiveFlags.SKIP */</span> &amp;&amp;</span><br><span class="line">    !<span class="title function_">isRef</span>(value) &amp;&amp;</span><br><span class="line">    !(value <span class="keyword">instanceof</span> <span class="title class_">VNode</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 执行 Observer构造函数 ，得到了一个实例对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Observer</span>(value, shallow, ssrMockReactivity)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent"></a>mountComponent</h2><blockquote>
<p><strong>src\core\instance\lifecycle.ts</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span>(<span class="params"></span></span><br><span class="line"><span class="params">  vm: Component,</span></span><br><span class="line"><span class="params">  el: Element | <span class="literal">null</span> | <span class="literal">undefined</span>,</span></span><br><span class="line"><span class="params">  hydrating?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Component</span> &#123;</span><br><span class="line">  vm.<span class="property">$el</span> = el</span><br><span class="line">  <span class="keyword">if</span> (!vm.<span class="property">$options</span>.<span class="property">render</span>) &#123;</span><br><span class="line">    vm.<span class="property">$options</span>.<span class="property">render</span> = createEmptyVNode</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; config.<span class="property">performance</span> &amp;&amp; mark)&#123;</span><br><span class="line">      <span class="comment">// ....</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 重要！这里是声明~~</span></span><br><span class="line">    <span class="comment">// 当执行这个updateComponent的过程中，实际上又会执行vm._render()</span></span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">watcherOptions</span>: <span class="title class_">WatcherOptions</span> = &#123;</span><br><span class="line">    <span class="title function_">before</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm.<span class="property">_isMounted</span> &amp;&amp; !vm.<span class="property">_isDestroyed</span>) &#123;</span><br><span class="line">        <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    watcherOptions.<span class="property">onTrack</span> = <span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">callHook</span>(vm, <span class="string">&#x27;renderTracked&#x27;</span>, [e])</span><br><span class="line">    watcherOptions.<span class="property">onTrigger</span> = <span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">callHook</span>(vm, <span class="string">&#x27;renderTriggered&#x27;</span>, [e])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">    vm,</span><br><span class="line">    updateComponent,</span><br><span class="line">    noop,</span><br><span class="line">    watcherOptions,</span><br><span class="line">    <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span></span><br><span class="line">  )</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// flush buffer for flush: &quot;pre&quot; watchers queued in setup()</span></span><br><span class="line">  <span class="keyword">const</span> preWatchers = vm.<span class="property">_preWatchers</span></span><br><span class="line">  <span class="keyword">if</span> (preWatchers) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; preWatchers.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      preWatchers[i].<span class="title function_">run</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm.<span class="property">_isMounted</span> = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">callHook</span>(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="render"><a href="#render" class="headerlink" title="_render"></a>_render</h2><blockquote>
<p><strong>src\core\instance\render.ts</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line">updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 调用updateComponent时，会执行render函数</span></span><br><span class="line">    vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. </span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = ()&#123;</span><br><span class="line">    <span class="comment">// 执行render函数的时候，实际上会读取模板中定义的data数据，也就会触发defineReactive中的getter函数，收集依赖</span></span><br><span class="line">    vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. ==&gt; 触发defineReactive中的getter函数</span></span><br><span class="line">dep.<span class="title function_">depend</span>() </span><br><span class="line"><span class="comment">// 4. ==&gt; 实际上调用watcher的addDep方法</span></span><br><span class="line"><span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>)  =&gt; ()&#123; dep.<span class="property">addSub</span>&#125;</span><br><span class="line"><span class="comment">// 5. 在watcher的addDep方法中，又会调用Dep类中的addSub方法</span></span><br><span class="line"><span class="comment">//    把这个watcher实例添加到Dep类的subs中</span></span><br><span class="line">dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>)</span><br><span class="line"><span class="comment">// 6. 最终执行dep.ts 中 this.subs.push(sub) =&gt; 把watcher放到subs中</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收集的时Dep.target =&gt; 当前正在计算的watcher收集起来，作为一个订阅者</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.<span class="property">$options</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_parentVnode &amp;&amp; vm.<span class="property">_isMounted</span>) &#123;</span><br><span class="line">    vm.<span class="property">$scopedSlots</span> = <span class="title function_">normalizeScopedSlots</span>(</span><br><span class="line">      vm.<span class="property">$parent</span>!,</span><br><span class="line">      _parentVnode.<span class="property">data</span>!.<span class="property">scopedSlots</span>,</span><br><span class="line">      vm.<span class="property">$slots</span>,</span><br><span class="line">      vm.<span class="property">$scopedSlots</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> (vm.<span class="property">_slotsProxy</span>) &#123;</span><br><span class="line">      <span class="title function_">syncSetupSlots</span>(vm.<span class="property">_slotsProxy</span>, vm.<span class="property">$scopedSlots</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">  <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">  vm.<span class="property">$vnode</span> = _parentVnode!</span><br><span class="line">  <span class="comment">// render self</span></span><br><span class="line">  <span class="keyword">let</span> vnode</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// There&#x27;s no need to maintain a stack because all render fns are called</span></span><br><span class="line">    <span class="comment">// separately from one another. Nested component&#x27;s render fns are called</span></span><br><span class="line">    <span class="comment">// when parent component is patched.</span></span><br><span class="line">    <span class="title function_">setCurrentInstance</span>(vm)</span><br><span class="line">    currentRenderingInstance = vm</span><br><span class="line">    <span class="comment">// 执行render函数</span></span><br><span class="line">    vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="attr">e</span>: any) &#123;</span><br><span class="line">    <span class="title function_">handleError</span>(e, vm, <span class="string">`render`</span>)</span><br><span class="line">    <span class="comment">// return error render result,</span></span><br><span class="line">    <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; vm.<span class="property">$options</span>.<span class="property">renderError</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        vnode = vm.<span class="property">$options</span>.<span class="property">renderError</span>.<span class="title function_">call</span>(</span><br><span class="line">          vm.<span class="property">_renderProxy</span>,</span><br><span class="line">          vm.<span class="property">$createElement</span>,</span><br><span class="line">          e</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">catch</span> (<span class="attr">e</span>: any) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">        vnode = vm.<span class="property">_vnode</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode = vm.<span class="property">_vnode</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentRenderingInstance = <span class="literal">null</span></span><br><span class="line">    <span class="title function_">setCurrentInstance</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if the returned array contains only a single node, allow it</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isArray</span>(vnode) &amp;&amp; vnode.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    vnode = vnode[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">  <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> <span class="title class_">VNode</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; <span class="title function_">isArray</span>(vnode)) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;Multiple root nodes returned from render function. Render function &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;should return a single root node.&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    vnode = <span class="title function_">createEmptyVNode</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// set parent</span></span><br><span class="line">  vnode.<span class="property">parent</span> = _parentVnode</span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>依赖收集 就是 订阅数据变化的 watcher 的收集</li>
<li>依赖收集的目的就是当这些响应式数据发生变化，触发了它们的setter的时候，能知道通知哪些订阅者去做相应的逻辑处理（视图更新）</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>Vue2-源码解析 <a href="https://ustbhuangyi.github.io/vue-analysis/">https://ustbhuangyi.github.io/vue-analysis/</a></li>
<li>Vue2-源码 <a href="https://vue-js.com/learn-vue/">https://vue-js.com/learn-vue/</a></li>
<li>React-源码解析<a href="https://react.iamkasong.com/">https://react.iamkasong.com/</a></li>
<li><a href="https://www.cnblogs.com/buluzombie/p/15204328.html">https://www.cnblogs.com/buluzombie/p/15204328.html</a> - 依赖收集</li>
<li><a href="https://www.bilibili.com/video/BV1Ti4y1w7TL?p=5&amp;vd_source=df92e41736899cbcfe83bba6d67cad3c">https://www.bilibili.com/video/BV1Ti4y1w7TL?p=5&amp;vd_source=df92e41736899cbcfe83bba6d67cad3c</a></li>
<li><a href="https://blog.csdn.net/hd101367816/article/details/114041232">https://blog.csdn.net/hd101367816/article/details/114041232</a></li>
<li><a href="https://blog.csdn.net/hd101367816/article/details/114042951">https://blog.csdn.net/hd101367816/article/details/114042951</a></li>
<li><a href="https://juejin.cn/post/7074422512318152718">纯干货！图解Vue响应式原理</a></li>
<li><a href="https://juejin.cn/post/6950826293923414047">Vue 源码解读（3）—— 响应式原理</a>‘</li>
<li><a href="https://juejin.cn/post/6844903597986037768">当面试官问你Vue响应式原理，你可以这么回答他</a></li>
<li><a href="https://juejin.cn/post/6844903598258651144#heading-12">【大型干货】手拉手带你过一遍vue部分源码</a></li>
<li><a href="https://juejin.cn/post/6857669921166491662">图解 Vue 响应式原理</a></li>
<li><a href="https://juejin.cn/post/6857669921166491662">图解</a></li>
<li>Vue源码阅读-<a href="https://github.com/liyongning/blog">https://github.com/liyongning/blog</a></li>
<li><a href="https://juejin.cn/post/6844903858850758670#heading-4">Vue响应式原理-理解Observer、Dep、Watcher</a></li>
<li><a href="https://juejin.cn/post/6919285014991470600#heading-3">你可以手写Vue2的响应式原理吗？</a></li>
<li><a href="https://juejin.cn/post/6844904113432444942">为什么说 Vue 的响应式更新精确到组件级别？（原理深度解析）</a></li>
<li><a href="https://juejin.cn/post/7173865309185671181">两年阿里</a></li>
<li><a href="https://juejin.cn/post/6992018709439053837#heading-12">尤雨溪国外教程：亲手带你写个简易版的Vue！</a></li>
</ol>
<hr>
<h1 id="PS-扩展知识"><a href="#PS-扩展知识" class="headerlink" title="PS.扩展知识"></a>PS.扩展知识</h1><h2 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor"></a>Object.getOwnPropertyDescriptor</h2><blockquote>
<p>返回指定对象上一个自有属性对应的属性描述符（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// const res = Object.getOwnPropertyDescriptor(obj,key)</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"></span><br><span class="line">res =&gt; &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">    <span class="attr">value</span>: <span class="string">&quot;hello&quot;</span></span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="typora快捷键"><a href="#typora快捷键" class="headerlink" title="typora快捷键"></a>typora快捷键</h1><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table>
<thead>
<tr>
<th>功能</th>
<th align="left">快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>代码</td>
<td align="left">Ctrl+Shift+`</td>
</tr>
<tr>
<td>标题1~6</td>
<td align="left">Ctrl + 1/2/3/4/5/6</td>
</tr>
<tr>
<td>段落</td>
<td align="left">Ctrl+0</td>
</tr>
<tr>
<td>提高/降低标题</td>
<td align="left">Ctrl + 提高     Ctrl  - 降低</td>
</tr>
<tr>
<td>表格</td>
<td align="left">Ctrl + T</td>
</tr>
<tr>
<td>引用</td>
<td align="left">Ctrl + Shift + Q    或 &gt; + 空格</td>
</tr>
<tr>
<td>加粗</td>
<td align="left">Ctrl + B</td>
</tr>
<tr>
<td>倾斜</td>
<td align="left">Ctrl + I</td>
</tr>
<tr>
<td>下划线</td>
<td align="left">Ctrl + U</td>
</tr>
<tr>
<td>选中一整行</td>
<td align="left">Ctrl + L</td>
</tr>
<tr>
<td>选中单词</td>
<td align="left">Ctrl + D</td>
</tr>
<tr>
<td>分割线</td>
<td align="left">+++ 回车 / — 回车</td>
</tr>
<tr>
<td>表格新增一行</td>
<td align="left">Ctrl + Enter</td>
</tr>
<tr>
<td>超链接</td>
<td align="left">Ctrl + K</td>
</tr>
<tr>
<td>打开大纲视图</td>
<td align="left">Ctrl + Shift + 1</td>
</tr>
<tr>
<td>打开文档列表视图</td>
<td align="left">Ctrl + Shift + 2</td>
</tr>
<tr>
<td>打开文件树视图</td>
<td align="left">Ctrl + Shift + 3</td>
</tr>
<tr>
<td>显示隐藏侧边栏</td>
<td align="left">Ctrl + Shift + L</td>
</tr>
<tr>
<td>放大</td>
<td align="left">Ctrl + Shift + +</td>
</tr>
<tr>
<td>缩小</td>
<td align="left">Ctrl + Shift  + -</td>
</tr>
<tr>
<td>100%大小</td>
<td align="left">Ctrl + Shift  + 0</td>
</tr>
<tr>
<td>快速打开</td>
<td align="left">Ctrl + P</td>
</tr>
<tr>
<td>打开</td>
<td align="left">Ctrl  + O</td>
</tr>
<tr>
<td>新建</td>
<td align="left">Ctrl  + N</td>
</tr>
<tr>
<td>新建窗口</td>
<td align="left">Ctrl + Shift + N</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>八股文</category>
      </categories>
  </entry>
</search>
